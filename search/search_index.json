{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chispa","text":"<p>chispa provides fast PySpark test helper methods that output descriptive error messages.</p> <p>This library makes it easy to write high quality PySpark code.</p> <p>Fun fact: \"chispa\" means Spark in Spanish ;)</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest version with <code>pip install chispa</code>.</p> <p>If you use Poetry, add this library as a development dependency with <code>poetry add chispa -G dev</code>.</p>"},{"location":"#column-equality","title":"Column equality","text":"<p>Suppose you have a function that removes the non-word characters in a string.</p> <pre><code>def remove_non_word_characters(col):\n    return F.regexp_replace(col, \"[^\\\\w\\\\s]+\", \"\")\n</code></pre> <p>Create a <code>SparkSession</code> so you can create DataFrames.</p> <pre><code>from pyspark.sql import SparkSession\n\nspark = (SparkSession.builder\n  .master(\"local\")\n  .appName(\"chispa\")\n  .getOrCreate())\n</code></pre> <p>Create a DataFrame with a column that contains strings with non-word characters, run the <code>remove_non_word_characters</code> function, and check that all these characters are removed with the chispa <code>assert_column_equality</code> method.</p> <pre><code>import pytest\n\nfrom chispa.column_comparer import assert_column_equality\nimport pyspark.sql.functions as F\n\ndef test_remove_non_word_characters_short():\n    data = [\n        (\"jo&amp;&amp;se\", \"jose\"),\n        (\"**li**\", \"li\"),\n        (\"#::luisa\", \"luisa\"),\n        (None, None)\n    ]\n    df = (spark.createDataFrame(data, [\"name\", \"expected_name\"])\n        .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\"))))\n    assert_column_equality(df, \"clean_name\", \"expected_name\")\n</code></pre> <p>Let's write another test that'll fail to see how the descriptive error message lets you easily debug the underlying issue.</p> <p>Here's the failing test:</p> <pre><code>def test_remove_non_word_characters_nice_error():\n    data = [\n        (\"matt7\", \"matt\"),\n        (\"bill&amp;\", \"bill\"),\n        (\"isabela*\", \"isabela\"),\n        (None, None)\n    ]\n    df = (spark.createDataFrame(data, [\"name\", \"expected_name\"])\n        .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\"))))\n    assert_column_equality(df, \"clean_name\", \"expected_name\")\n</code></pre> <p>Here's the nicely formatted error message:</p> <p></p> <p>You can see the <code>matt7</code> / <code>matt</code> row of data is what's causing the error (note it's highlighted in red).  The other rows are colored blue because they're equal.</p>"},{"location":"#dataframe-equality","title":"DataFrame equality","text":"<p>We can also test the <code>remove_non_word_characters</code> method by creating two DataFrames and verifying that they're equal.</p> <p>Creating two DataFrames is slower and requires more code, but comparing entire DataFrames is necessary for some tests.</p> <pre><code>from chispa.dataframe_comparer import *\n\ndef test_remove_non_word_characters_long():\n    source_data = [\n        (\"jo&amp;&amp;se\",),\n        (\"**li**\",),\n        (\"#::luisa\",),\n        (None,)\n    ]\n    source_df = spark.createDataFrame(source_data, [\"name\"])\n\n    actual_df = source_df.withColumn(\n        \"clean_name\",\n        remove_non_word_characters(F.col(\"name\"))\n    )\n\n    expected_data = [\n        (\"jo&amp;&amp;se\", \"jose\"),\n        (\"**li**\", \"li\"),\n        (\"#::luisa\", \"luisa\"),\n        (None, None)\n    ]\n    expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"])\n\n    assert_df_equality(actual_df, expected_df)\n</code></pre> <p>Let's write another test that'll return an error, so you can see the descriptive error message.</p> <pre><code>def test_remove_non_word_characters_long_error():\n    source_data = [\n        (\"matt7\",),\n        (\"bill&amp;\",),\n        (\"isabela*\",),\n        (None,)\n    ]\n    source_df = spark.createDataFrame(source_data, [\"name\"])\n\n    actual_df = source_df.withColumn(\n        \"clean_name\",\n        remove_non_word_characters(F.col(\"name\"))\n    )\n\n    expected_data = [\n        (\"matt7\", \"matt\"),\n        (\"bill&amp;\", \"bill\"),\n        (\"isabela*\", \"isabela\"),\n        (None, None)\n    ]\n    expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"])\n\n    assert_df_equality(actual_df, expected_df)\n</code></pre> <p>Here's the nicely formatted error message:</p> <p></p>"},{"location":"#ignore-row-order","title":"Ignore row order","text":"<p>You can easily compare DataFrames, ignoring the order of the rows.  The content of the DataFrames is usually what matters, not the order of the rows.</p> <p>Here are the contents of <code>df1</code>:</p> <pre><code>+--------+\n|some_num|\n+--------+\n|       1|\n|       2|\n|       3|\n+--------+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+--------+\n|some_num|\n+--------+\n|       2|\n|       1|\n|       3|\n+--------+\n</code></pre> <p>Here's how to confirm <code>df1</code> and <code>df2</code> are equal when the row order is ignored.</p> <pre><code>assert_df_equality(df1, df2, ignore_row_order=True)\n</code></pre> <p>If you don't specify to <code>ignore_row_order</code> then the test will error out with this message:</p> <p></p> <p>The rows aren't ordered by default because sorting slows down the function.</p>"},{"location":"#ignore-column-order","title":"Ignore column order","text":"<p>This section explains how to compare DataFrames, ignoring the order of the columns.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+----+----+\n|num1|num2|\n+----+----+\n|   1|   7|\n|   2|   8|\n|   3|   9|\n+----+----+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+----+----+\n|num2|num1|\n+----+----+\n|   7|   1|\n|   8|   2|\n|   9|   3|\n+----+----+\n</code></pre> <p>Here's how to compare the equality of <code>df1</code> and <code>df2</code>, ignoring the column order:</p> <pre><code>assert_df_equality(df1, df2, ignore_column_order=True)\n</code></pre> <p>Here's the error message you'll see if you run <code>assert_df_equality(df1, df2)</code>, without ignoring the column order.</p> <p></p>"},{"location":"#ignore-specific-columns","title":"Ignore specific columns","text":"<p>This section explains how to compare DataFrames, ignoring specific columns.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+------------+-------------+\n|    name    | clean_name  |\n+------------+-------------+\n| \"matt7\"    |   \"matt7\"    |\n| \"bill&amp;\"    |   \"bill\"    |\n| \"isabela*\" |   \"isabela\" |\n| \"None\"     |   \"None\"    |\n+------------+-------------+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+------------+-------------+\n|    name    | clean_name  |\n+------------+-------------+\n| \"matt7\"    |   \"matt\"    |\n| \"bill&amp;\"    |   \"bill\"    |\n| \"isabela*\" |   \"isabela\" |\n| \"None\"     |   \"None\"    |\n+------------+-------------+\n</code></pre> <p>Here's how to compare the equality of <code>df1</code> and <code>df2</code>, ignoring the column <code>clean_name</code>:</p> <pre><code>assert_df_equality(df1, df2, ignore_columns=[\"clean_name\"])\n</code></pre> <p>Here's the error message you'll see if you run <code>assert_df_equality(df1, df2)</code>, without ignoring the column <code>clean_name</code>.</p> <p></p>"},{"location":"#ignore-nullability","title":"Ignore nullability","text":"<p>Each column in a schema has three properties: a name, data type, and nullable property.  The column can accept null values if <code>nullable</code> is set to true.</p> <p>You'll sometimes want to ignore the nullable property when making DataFrame comparisons.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+-----+---+\n| name|age|\n+-----+---+\n| juan|  7|\n|bruna|  8|\n+-----+---+\n</code></pre> <p>And this <code>df2</code>:</p> <pre><code>+-----+---+\n| name|age|\n+-----+---+\n| juan|  7|\n|bruna|  8|\n+-----+---+\n</code></pre> <p>You might be surprised to find that in this example, <code>df1</code> and <code>df2</code> are not equal and will error out with this message:</p> <p></p> <p>Examine the code in this contrived example to better understand the error:</p> <pre><code>def ignore_nullable_property():\n    s1 = StructType([\n       StructField(\"name\", StringType(), True),\n       StructField(\"age\", IntegerType(), True)])\n    df1 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s1)\n    s2 = StructType([\n       StructField(\"name\", StringType(), True),\n       StructField(\"age\", IntegerType(), False)])\n    df2 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s2)\n    assert_df_equality(df1, df2)\n</code></pre> <p>You can ignore the nullable property when assessing equality by adding a flag:</p> <pre><code>assert_df_equality(df1, df2, ignore_nullable=True)\n</code></pre> <p>Elements contained within an <code>ArrayType()</code> also have a nullable property, in addition to the nullable property of the column schema. These are also ignored when passing <code>ignore_nullable=True</code>.</p> <p>Again, examine the following code to understand the error that <code>ignore_nullable=True</code> bypasses:</p> <pre><code>def ignore_nullable_property_array():\n    s1 = StructType([\n        StructField(\"name\", StringType(), True),\n        StructField(\"coords\", ArrayType(DoubleType(), True), True),])\n    df1 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s1)\n    s2 = StructType([\n        StructField(\"name\", StringType(), True),\n        StructField(\"coords\", ArrayType(DoubleType(), False), True),])\n    df2 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s2)\n    assert_df_equality(df1, df2)\n</code></pre>"},{"location":"#allow-nan-equality","title":"Allow NaN equality","text":"<p>Python has NaN (not a number) values and two NaN values are not considered equal by default.  Create two NaN values, compare them, and confirm they're not considered equal by default.</p> <pre><code>nan1 = float('nan')\nnan2 = float('nan')\nnan1 == nan2 # False\n</code></pre> <p>pandas considers NaN values to be equal by default, but this library requires you to set a flag to consider two NaN values to be equal.</p> <pre><code>assert_df_equality(df1, df2, allow_nan_equality=True)\n</code></pre>"},{"location":"#customize-formatting","title":"Customize formatting","text":"<p>You can specify custom formats for the printed error messages as follows:</p> <pre><code>from chispa import FormattingConfig\n\nformats = FormattingConfig(\n        mismatched_rows={\"color\": \"light_yellow\"},\n        matched_rows={\"color\": \"cyan\", \"style\": \"bold\"},\n        mismatched_cells={\"color\": \"purple\"},\n        matched_cells={\"color\": \"blue\"},\n    )\n\nassert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre> <p>or similarly:</p> <pre><code>from chispa import FormattingConfig, Color, Style\n\nformats = FormattingConfig(\n        mismatched_rows={\"color\": Color.LIGHT_YELLOW},\n        matched_rows={\"color\": Color.CYAN, \"style\": Style.BOLD},\n        mismatched_cells={\"color\": Color.PURPLE},\n        matched_cells={\"color\": Color.BLUE},\n    )\n\nassert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre> <p>You can also define these formats in <code>conftest.py</code> and inject them via a fixture:</p> <pre><code>@pytest.fixture()\ndef chispa_formats():\n    return FormattingConfig(\n        mismatched_rows={\"color\": \"light_yellow\"},\n        matched_rows={\"color\": \"cyan\", \"style\": \"bold\"},\n        mismatched_cells={\"color\": \"purple\"},\n        matched_cells={\"color\": \"blue\"},\n    )\n\ndef test_shows_assert_basic_rows_equality(chispa_formats):\n  ...\n  assert_basic_rows_equality(df1.collect(), df2.collect(), formats=chispa_formats)\n</code></pre> <p></p>"},{"location":"#approximate-column-equality","title":"Approximate column equality","text":"<p>We can check if columns are approximately equal, which is especially useful for floating number comparisons.</p> <p>Here's a test that creates a DataFrame with two floating point columns and verifies that the columns are approximately equal.  In this example, values are considered approximately equal if the difference is less than 0.1.</p> <pre><code>def test_approx_col_equality_same():\n    data = [\n        (1.1, 1.1),\n        (2.2, 2.15),\n        (3.3, 3.37),\n        (None, None)\n    ]\n    df = spark.createDataFrame(data, [\"num1\", \"num2\"])\n    assert_approx_column_equality(df, \"num1\", \"num2\", 0.1)\n</code></pre> <p>Here's an example of a test with columns that are not approximately equal.</p> <pre><code>def test_approx_col_equality_different():\n    data = [\n        (1.1, 1.1),\n        (2.2, 2.15),\n        (3.3, 5.0),\n        (None, None)\n    ]\n    df = spark.createDataFrame(data, [\"num1\", \"num2\"])\n    assert_approx_column_equality(df, \"num1\", \"num2\", 0.1)\n</code></pre> <p>This failing test will output a readable error message so the issue is easy to debug.</p> <p></p>"},{"location":"#approximate-dataframe-equality","title":"Approximate DataFrame equality","text":"<p>Let's create two DataFrames and confirm they're approximately equal.</p> <pre><code>def test_approx_df_equality_same():\n    data1 = [\n        (1.1, \"a\"),\n        (2.2, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1.05, \"a\"),\n        (2.13, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"letter\"])\n\n    assert_approx_df_equality(df1, df2, 0.1)\n</code></pre> <p>The <code>assert_approx_df_equality</code> method is smart and will only perform approximate equality operations for floating point numbers in DataFrames.  It'll perform regular equality for strings and other types.</p> <p>Let's perform an approximate equality comparison for two DataFrames that are not equal.</p> <pre><code>def test_approx_df_equality_different():\n    data1 = [\n        (1.1, \"a\"),\n        (2.2, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1.1, \"a\"),\n        (5.0, \"b\"),\n        (3.3, \"z\"),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"letter\"])\n\n    assert_approx_df_equality(df1, df2, 0.1)\n</code></pre> <p>Here's the pretty error message that's outputted:</p> <p></p>"},{"location":"#schema-mismatch-messages","title":"Schema mismatch messages","text":"<p>DataFrame equality messages peform schema comparisons before analyzing the actual content of the DataFrames.  DataFrames that don't have the same schemas should error out as fast as possible.</p> <p>Let's compare a DataFrame that has a string column an integer column with a DataFrame that has two integer columns to observe the schema mismatch message.</p> <pre><code>def test_schema_mismatch_message():\n    data1 = [\n        (1, \"a\"),\n        (2, \"b\"),\n        (3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1, 6),\n        (2, 7),\n        (3, 8),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"num2\"])\n\n    assert_df_equality(df1, df2)\n</code></pre> <p>Here's the error message:</p> <p></p>"},{"location":"#supported-pyspark-python-versions","title":"Supported PySpark / Python versions","text":"<p>chispa currently supports PySpark 2.4+ and Python 3.5+.</p> <p>Use chispa v0.8.2 if you're using an older Python version.</p> <p>PySpark 2 support will be dropped when chispa 1.x is released.</p>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>TODO: Need to benchmark these methods vs. the spark-testing-base ones</p>"},{"location":"#developing-chispa-on-your-local-machine","title":"Developing chispa on your local machine","text":"<p>You are encouraged to clone and/or fork this repo.</p> <p>This project uses Poetry for packaging and dependency management.</p> <ul> <li>Setup the virtual environment with <code>poetry install</code></li> <li>Run the tests with <code>poetry run pytest tests</code></li> </ul> <p>Studying the codebase is a great way to learn about PySpark!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Anyone is encouraged to submit a pull request, open an issue, or submit a bug report.</p> <p>We're happy to promote folks to be library maintainers if they make good contributions.</p>"},{"location":"reference/SUMMARY/","title":"API Docs","text":"<ul> <li>chispa<ul> <li>bcolors</li> <li>column_comparer</li> <li>common_enums</li> <li>dataframe_comparer</li> <li>default_formats</li> <li>formatting<ul> <li>format_string</li> <li>formats</li> <li>formatting_config</li> </ul> </li> <li>number_helpers</li> <li>row_comparer</li> <li>rows_comparer</li> <li>schema_comparer</li> <li>structfield_comparer</li> </ul> </li> </ul>"},{"location":"reference/chispa/","title":"Index","text":""},{"location":"reference/chispa/#chispa.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/#chispa.ColumnsNotEqualError","title":"<code>ColumnsNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The columns are not equal</p> Source code in <code>chispa/column_comparer.py</code> <pre><code>class ColumnsNotEqualError(Exception):\n    \"\"\"The columns are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/#chispa.DataFramesNotEqualError","title":"<code>DataFramesNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The DataFrames are not equal</p> Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>class DataFramesNotEqualError(Exception):\n    \"\"\"The DataFrames are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/#chispa.DefaultFormats","title":"<code>DefaultFormats</code>  <code>dataclass</code>","text":"<p>This class is now deprecated and should be removed in a future release.</p> Source code in <code>chispa/default_formats.py</code> <pre><code>@dataclass\nclass DefaultFormats:\n    \"\"\"\n    This class is now deprecated and should be removed in a future release.\n    \"\"\"\n\n    mismatched_rows: list[str] = field(default_factory=lambda: [\"red\"])\n    matched_rows: list[str] = field(default_factory=lambda: [\"blue\"])\n    mismatched_cells: list[str] = field(default_factory=lambda: [\"red\", \"underline\"])\n    matched_cells: list[str] = field(default_factory=lambda: [\"blue\"])\n\n    def __post_init__(self) -&gt; None:\n        warnings.warn(\n            \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n        )\n</code></pre>"},{"location":"reference/chispa/#chispa.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/#chispa.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/#chispa.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/#chispa.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/#chispa.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"},{"location":"reference/chispa/#chispa.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/bcolors/","title":"Bcolors","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.underline_text","title":"<code>underline_text(input_text)</code>","text":"<p>Takes an input string and returns a white, underlined string (based on PrettyTable formatting)</p> Source code in <code>chispa/bcolors.py</code> <pre><code>def underline_text(input_text: str) -&gt; str:\n    \"\"\"\n    Takes an input string and returns a white, underlined string (based on PrettyTable formatting)\n    \"\"\"\n    warnings.warn(\n        \"The `underline_text` function is deprecated and will be removed in a future version.\", DeprecationWarning\n    )\n    return bcolors.White + bcolors.Underline + input_text + bcolors.NC + bcolors.LightRed\n</code></pre>"},{"location":"reference/chispa/column_comparer/","title":"Column comparer","text":""},{"location":"reference/chispa/column_comparer/#chispa.column_comparer.ColumnsNotEqualError","title":"<code>ColumnsNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The columns are not equal</p> Source code in <code>chispa/column_comparer.py</code> <pre><code>class ColumnsNotEqualError(Exception):\n    \"\"\"The columns are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/common_enums/","title":"Common enums","text":""},{"location":"reference/chispa/dataframe_comparer/","title":"Dataframe comparer","text":""},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.DataFramesNotEqualError","title":"<code>DataFramesNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The DataFrames are not equal</p> Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>class DataFramesNotEqualError(Exception):\n    \"\"\"The DataFrames are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/default_formats/","title":"Default formats","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats","title":"<code>DefaultFormats</code>  <code>dataclass</code>","text":"<p>This class is now deprecated and should be removed in a future release.</p> Source code in <code>chispa/default_formats.py</code> <pre><code>@dataclass\nclass DefaultFormats:\n    \"\"\"\n    This class is now deprecated and should be removed in a future release.\n    \"\"\"\n\n    mismatched_rows: list[str] = field(default_factory=lambda: [\"red\"])\n    matched_rows: list[str] = field(default_factory=lambda: [\"blue\"])\n    mismatched_cells: list[str] = field(default_factory=lambda: [\"red\", \"underline\"])\n    matched_cells: list[str] = field(default_factory=lambda: [\"blue\"])\n\n    def __post_init__(self) -&gt; None:\n        warnings.warn(\n            \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n        )\n</code></pre>"},{"location":"reference/chispa/number_helpers/","title":"Number helpers","text":""},{"location":"reference/chispa/row_comparer/","title":"Row comparer","text":""},{"location":"reference/chispa/rows_comparer/","title":"Rows comparer","text":""},{"location":"reference/chispa/schema_comparer/","title":"Schema comparer","text":""},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.SchemasNotEqualError","title":"<code>SchemasNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The schemas are not equal</p> Source code in <code>chispa/schema_comparer.py</code> <pre><code>class SchemasNotEqualError(Exception):\n    \"\"\"The schemas are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.are_datatypes_equal_ignore_nullable","title":"<code>are_datatypes_equal_ignore_nullable(dt1, dt2, ignore_metadata=False)</code>","text":"<p>Checks if datatypes are equal, descending into structs and arrays to ignore nullability.</p> Source code in <code>chispa/schema_comparer.py</code> <pre><code>@typing.no_type_check\ndef are_datatypes_equal_ignore_nullable(dt1, dt2, ignore_metadata: bool = False) -&gt; bool:\n    \"\"\"Checks if datatypes are equal, descending into structs and arrays to\n    ignore nullability.\n    \"\"\"\n    if dt1.typeName() == dt2.typeName():\n        # Account for array types by inspecting elementType.\n        if dt1.typeName() == TypeName.ARRAY:\n            return are_datatypes_equal_ignore_nullable(dt1.elementType, dt2.elementType, ignore_metadata)\n        elif dt1.typeName() == TypeName.STRUCT:\n            return are_schemas_equal_ignore_nullable(dt1, dt2, ignore_metadata)\n        else:\n            # Some data types have additional attributes (e.g. precision and scale for Decimal),\n            # and the type equality check must also check for equality of these attributes.\n            return vars(dt1) == vars(dt2)\n    else:\n        return False\n</code></pre>"},{"location":"reference/chispa/structfield_comparer/","title":"Structfield comparer","text":""},{"location":"reference/chispa/formatting/","title":"Index","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/formatting/format_string/","title":"Format string","text":""},{"location":"reference/chispa/formatting/formats/","title":"Formats","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/formatting/formatting_config/","title":"Formatting config","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"}]}