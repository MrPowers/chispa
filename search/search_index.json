{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chispa","text":"<p>chispa provides fast PySpark test helper methods that output descriptive error messages.</p> <p>This library makes it easy to write high quality PySpark code.</p> <p>Fun fact: \"chispa\" means Spark in Spanish ;)</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest version with</p> <pre><code>pip install chispa\n</code></pre> <p>Or if you use Poetry add this library as a development dependency with</p> <pre><code>poetry add chispa --group dev\n</code></pre>"},{"location":"#column-equality","title":"Column equality","text":"<p>Suppose you have a function that removes the non-word characters in a string.</p> <pre><code>def remove_non_word_characters(col):\n    return F.regexp_replace(col, \"[^\\\\w\\\\s]+\", \"\")\n</code></pre> <p>Create a <code>SparkSession</code> so you can create DataFrames.</p> <pre><code>from pyspark.sql import SparkSession\n\nspark = (SparkSession.builder\n  .master(\"local\")\n  .appName(\"chispa\")\n  .getOrCreate())\n</code></pre> <p>Create a DataFrame with a column that contains strings with non-word characters, run the <code>remove_non_word_characters</code> function, and check that all these characters are removed with the chispa <code>assert_column_equality</code> method.</p> <pre><code>import pytest\n\nfrom chispa.column_comparer import assert_column_equality\nimport pyspark.sql.functions as F\n\ndef test_remove_non_word_characters_short():\n    data = [\n        (\"jo&amp;&amp;se\", \"jose\"),\n        (\"**li**\", \"li\"),\n        (\"#::luisa\", \"luisa\"),\n        (None, None)\n    ]\n    df = (spark.createDataFrame(data, [\"name\", \"expected_name\"])\n        .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\"))))\n    assert_column_equality(df, \"clean_name\", \"expected_name\")\n</code></pre> <p>Let's write another test that'll fail to see how the descriptive error message lets you easily debug the underlying issue.</p> <p>Here's the failing test:</p> <pre><code>def test_remove_non_word_characters_nice_error():\n    data = [\n        (\"matt7\", \"matt\"),\n        (\"bill&amp;\", \"bill\"),\n        (\"isabela*\", \"isabela\"),\n        (None, None)\n    ]\n    df = (spark.createDataFrame(data, [\"name\", \"expected_name\"])\n        .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\"))))\n    assert_column_equality(df, \"clean_name\", \"expected_name\")\n</code></pre> <p>Here's the nicely formatted error message:</p> <p></p> <p>You can see the <code>matt7</code> / <code>matt</code> row of data is what's causing the error (note it's highlighted in red).  The other rows are colored blue because they're equal.</p>"},{"location":"#dataframe-equality","title":"DataFrame equality","text":"<p>We can also test the <code>remove_non_word_characters</code> method by creating two DataFrames and verifying that they're equal.</p> <p>Creating two DataFrames is slower and requires more code, but comparing entire DataFrames is necessary for some tests.</p> <pre><code>from chispa.dataframe_comparer import *\n\ndef test_remove_non_word_characters_long():\n    source_data = [\n        (\"jo&amp;&amp;se\",),\n        (\"**li**\",),\n        (\"#::luisa\",),\n        (None,)\n    ]\n    source_df = spark.createDataFrame(source_data, [\"name\"])\n\n    actual_df = source_df.withColumn(\n        \"clean_name\",\n        remove_non_word_characters(F.col(\"name\"))\n    )\n\n    expected_data = [\n        (\"jo&amp;&amp;se\", \"jose\"),\n        (\"**li**\", \"li\"),\n        (\"#::luisa\", \"luisa\"),\n        (None, None)\n    ]\n    expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"])\n\n    assert_df_equality(actual_df, expected_df)\n</code></pre> <p>Let's write another test that'll return an error, so you can see the descriptive error message.</p> <pre><code>def test_remove_non_word_characters_long_error():\n    source_data = [\n        (\"matt7\",),\n        (\"bill&amp;\",),\n        (\"isabela*\",),\n        (None,)\n    ]\n    source_df = spark.createDataFrame(source_data, [\"name\"])\n\n    actual_df = source_df.withColumn(\n        \"clean_name\",\n        remove_non_word_characters(F.col(\"name\"))\n    )\n\n    expected_data = [\n        (\"matt7\", \"matt\"),\n        (\"bill&amp;\", \"bill\"),\n        (\"isabela*\", \"isabela\"),\n        (None, None)\n    ]\n    expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"])\n\n    assert_df_equality(actual_df, expected_df)\n</code></pre> <p>Here's the nicely formatted error message:</p> <p></p>"},{"location":"#ignore-row-order","title":"Ignore row order","text":"<p>You can easily compare DataFrames, ignoring the order of the rows.  The content of the DataFrames is usually what matters, not the order of the rows.</p> <p>Here are the contents of <code>df1</code>:</p> <pre><code>+--------+\n|some_num|\n+--------+\n|       1|\n|       2|\n|       3|\n+--------+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+--------+\n|some_num|\n+--------+\n|       2|\n|       1|\n|       3|\n+--------+\n</code></pre> <p>Here's how to confirm <code>df1</code> and <code>df2</code> are equal when the row order is ignored.</p> <pre><code>assert_df_equality(df1, df2, ignore_row_order=True)\n</code></pre> <p>If you don't specify to <code>ignore_row_order</code> then the test will error out with this message:</p> <p></p> <p>The rows aren't ordered by default because sorting slows down the function.</p>"},{"location":"#ignore-column-order","title":"Ignore column order","text":"<p>This section explains how to compare DataFrames, ignoring the order of the columns.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+----+----+\n|num1|num2|\n+----+----+\n|   1|   7|\n|   2|   8|\n|   3|   9|\n+----+----+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+----+----+\n|num2|num1|\n+----+----+\n|   7|   1|\n|   8|   2|\n|   9|   3|\n+----+----+\n</code></pre> <p>Here's how to compare the equality of <code>df1</code> and <code>df2</code>, ignoring the column order:</p> <pre><code>assert_df_equality(df1, df2, ignore_column_order=True)\n</code></pre> <p>Here's the error message you'll see if you run <code>assert_df_equality(df1, df2)</code>, without ignoring the column order.</p> <p></p>"},{"location":"#ignore-specific-columns","title":"Ignore specific columns","text":"<p>This section explains how to compare DataFrames, ignoring specific columns.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+------------+-------------+\n|    name    | clean_name  |\n+------------+-------------+\n| \"matt7\"    |   \"matt7\"    |\n| \"bill&amp;\"    |   \"bill\"    |\n| \"isabela*\" |   \"isabela\" |\n| \"None\"     |   \"None\"    |\n+------------+-------------+\n</code></pre> <p>Here are the contents of <code>df2</code>:</p> <pre><code>+------------+-------------+\n|    name    | clean_name  |\n+------------+-------------+\n| \"matt7\"    |   \"matt\"    |\n| \"bill&amp;\"    |   \"bill\"    |\n| \"isabela*\" |   \"isabela\" |\n| \"None\"     |   \"None\"    |\n+------------+-------------+\n</code></pre> <p>Here's how to compare the equality of <code>df1</code> and <code>df2</code>, ignoring the column <code>clean_name</code>:</p> <pre><code>assert_df_equality(df1, df2, ignore_columns=[\"clean_name\"])\n</code></pre> <p>Here's the error message you'll see if you run <code>assert_df_equality(df1, df2)</code>, without ignoring the column <code>clean_name</code>.</p> <p></p>"},{"location":"#ignore-nullability","title":"Ignore nullability","text":"<p>Each column in a schema has three properties: a name, data type, and nullable property.  The column can accept null values if <code>nullable</code> is set to true.</p> <p>You'll sometimes want to ignore the nullable property when making DataFrame comparisons.</p> <p>Suppose you have the following <code>df1</code>:</p> <pre><code>+-----+---+\n| name|age|\n+-----+---+\n| juan|  7|\n|bruna|  8|\n+-----+---+\n</code></pre> <p>And this <code>df2</code>:</p> <pre><code>+-----+---+\n| name|age|\n+-----+---+\n| juan|  7|\n|bruna|  8|\n+-----+---+\n</code></pre> <p>You might be surprised to find that in this example, <code>df1</code> and <code>df2</code> are not equal and will error out with this message:</p> <p></p> <p>Examine the code in this contrived example to better understand the error:</p> <pre><code>def ignore_nullable_property():\n    s1 = StructType([\n       StructField(\"name\", StringType(), True),\n       StructField(\"age\", IntegerType(), True)])\n    df1 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s1)\n    s2 = StructType([\n       StructField(\"name\", StringType(), True),\n       StructField(\"age\", IntegerType(), False)])\n    df2 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s2)\n    assert_df_equality(df1, df2)\n</code></pre> <p>You can ignore the nullable property when assessing equality by adding a flag:</p> <pre><code>assert_df_equality(df1, df2, ignore_nullable=True)\n</code></pre> <p>Elements contained within an <code>ArrayType()</code> also have a nullable property, in addition to the nullable property of the column schema. These are also ignored when passing <code>ignore_nullable=True</code>.</p> <p>Again, examine the following code to understand the error that <code>ignore_nullable=True</code> bypasses:</p> <pre><code>def ignore_nullable_property_array():\n    s1 = StructType([\n        StructField(\"name\", StringType(), True),\n        StructField(\"coords\", ArrayType(DoubleType(), True), True),])\n    df1 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s1)\n    s2 = StructType([\n        StructField(\"name\", StringType(), True),\n        StructField(\"coords\", ArrayType(DoubleType(), False), True),])\n    df2 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s2)\n    assert_df_equality(df1, df2)\n</code></pre>"},{"location":"#allow-nan-equality","title":"Allow NaN equality","text":"<p>Python has NaN (not a number) values and two NaN values are not considered equal by default.  Create two NaN values, compare them, and confirm they're not considered equal by default.</p> <pre><code>nan1 = float('nan')\nnan2 = float('nan')\nnan1 == nan2 # False\n</code></pre> <p>pandas considers NaN values to be equal by default, but this library requires you to set a flag to consider two NaN values to be equal.</p> <pre><code>assert_df_equality(df1, df2, allow_nan_equality=True)\n</code></pre>"},{"location":"#customize-formatting","title":"Customize formatting","text":"<p>You can specify custom formats for the printed error messages as follows:</p> <pre><code>from chispa import FormattingConfig\n\nformats = FormattingConfig(\n        mismatched_rows={\"color\": \"light_yellow\"},\n        matched_rows={\"color\": \"cyan\", \"style\": \"bold\"},\n        mismatched_cells={\"color\": \"purple\"},\n        matched_cells={\"color\": \"blue\"},\n    )\n\nassert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre> <p>or similarly:</p> <pre><code>from chispa import FormattingConfig, Color, Style\n\nformats = FormattingConfig(\n        mismatched_rows={\"color\": Color.LIGHT_YELLOW},\n        matched_rows={\"color\": Color.CYAN, \"style\": Style.BOLD},\n        mismatched_cells={\"color\": Color.PURPLE},\n        matched_cells={\"color\": Color.BLUE},\n    )\n\nassert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre> <p>You can also define these formats in <code>conftest.py</code> and inject them via a fixture:</p> <pre><code>@pytest.fixture()\ndef chispa_formats():\n    return FormattingConfig(\n        mismatched_rows={\"color\": \"light_yellow\"},\n        matched_rows={\"color\": \"cyan\", \"style\": \"bold\"},\n        mismatched_cells={\"color\": \"purple\"},\n        matched_cells={\"color\": \"blue\"},\n    )\n\ndef test_shows_assert_basic_rows_equality(chispa_formats):\n  ...\n  assert_basic_rows_equality(df1.collect(), df2.collect(), formats=chispa_formats)\n</code></pre> <p></p>"},{"location":"#approximate-column-equality","title":"Approximate column equality","text":"<p>We can check if columns are approximately equal, which is especially useful for floating number comparisons.</p> <p>Here's a test that creates a DataFrame with two floating point columns and verifies that the columns are approximately equal.  In this example, values are considered approximately equal if the difference is less than 0.1.</p> <pre><code>def test_approx_col_equality_same():\n    data = [\n        (1.1, 1.1),\n        (2.2, 2.15),\n        (3.3, 3.37),\n        (None, None)\n    ]\n    df = spark.createDataFrame(data, [\"num1\", \"num2\"])\n    assert_approx_column_equality(df, \"num1\", \"num2\", 0.1)\n</code></pre> <p>Here's an example of a test with columns that are not approximately equal.</p> <pre><code>def test_approx_col_equality_different():\n    data = [\n        (1.1, 1.1),\n        (2.2, 2.15),\n        (3.3, 5.0),\n        (None, None)\n    ]\n    df = spark.createDataFrame(data, [\"num1\", \"num2\"])\n    assert_approx_column_equality(df, \"num1\", \"num2\", 0.1)\n</code></pre> <p>This failing test will output a readable error message so the issue is easy to debug.</p> <p></p>"},{"location":"#approximate-dataframe-equality","title":"Approximate DataFrame equality","text":"<p>Let's create two DataFrames and confirm they're approximately equal.</p> <pre><code>def test_approx_df_equality_same():\n    data1 = [\n        (1.1, \"a\"),\n        (2.2, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1.05, \"a\"),\n        (2.13, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"letter\"])\n\n    assert_approx_df_equality(df1, df2, 0.1)\n</code></pre> <p>The <code>assert_approx_df_equality</code> method is smart and will only perform approximate equality operations for floating point numbers in DataFrames.  It'll perform regular equality for strings and other types.</p> <p>Let's perform an approximate equality comparison for two DataFrames that are not equal.</p> <pre><code>def test_approx_df_equality_different():\n    data1 = [\n        (1.1, \"a\"),\n        (2.2, \"b\"),\n        (3.3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1.1, \"a\"),\n        (5.0, \"b\"),\n        (3.3, \"z\"),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"letter\"])\n\n    assert_approx_df_equality(df1, df2, 0.1)\n</code></pre> <p>Here's the pretty error message that's outputted:</p> <p></p>"},{"location":"#schema-mismatch-messages","title":"Schema mismatch messages","text":"<p>DataFrame equality messages peform schema comparisons before analyzing the actual content of the DataFrames.  DataFrames that don't have the same schemas should error out as fast as possible.</p> <p>Let's compare a DataFrame that has a string column an integer column with a DataFrame that has two integer columns to observe the schema mismatch message.</p> <pre><code>def test_schema_mismatch_message():\n    data1 = [\n        (1, \"a\"),\n        (2, \"b\"),\n        (3, \"c\"),\n        (None, None)\n    ]\n    df1 = spark.createDataFrame(data1, [\"num\", \"letter\"])\n\n    data2 = [\n        (1, 6),\n        (2, 7),\n        (3, 8),\n        (None, None)\n    ]\n    df2 = spark.createDataFrame(data2, [\"num\", \"num2\"])\n\n    assert_df_equality(df1, df2)\n</code></pre> <p>Here's the error message:</p> <p></p>"},{"location":"#supported-pyspark-python-versions","title":"Supported PySpark / Python versions","text":"<p>chispa currently supports PySpark 2.4+ and Python 3.5+.</p> <p>Use chispa v0.8.2 if you're using an older Python version.</p> <p>PySpark 2 support will be dropped when chispa 1.x is released.</p>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>TODO: Need to benchmark these methods vs. the spark-testing-base ones</p>"},{"location":"#developing-chispa-on-your-local-machine","title":"Developing chispa on your local machine","text":"<p>You are encouraged to clone and/or fork this repo.</p> <p>This project uses Poetry for packaging and dependency management.</p> <ul> <li>Setup the virtual environment with <code>poetry install</code></li> <li>Run the tests with <code>poetry run pytest tests</code></li> </ul> <p>Studying the codebase is a great way to learn about PySpark!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Anyone is encouraged to submit a pull request, open an issue, or submit a bug report.</p> <p>We're happy to promote folks to be library maintainers if they make good contributions.</p>"},{"location":"reference/SUMMARY/","title":"API Docs","text":"<ul> <li>chispa<ul> <li>bcolors</li> <li>column_comparer</li> <li>common_enums</li> <li>dataframe_comparer</li> <li>default_formats</li> <li>formatting<ul> <li>format_string</li> <li>formats</li> <li>formatting_config</li> </ul> </li> <li>number_helpers</li> <li>row_comparer</li> <li>rows_comparer</li> <li>schema_comparer</li> <li>structfield_comparer</li> </ul> </li> </ul>"},{"location":"reference/chispa/","title":"Index","text":""},{"location":"reference/chispa/#chispa.__all__","title":"<code>__all__ = ('Chispa', 'Color', 'ColumnsNotEqualError', 'DataFramesNotEqualError', 'DefaultFormats', 'Format', 'FormattingConfig', 'SchemasNotEqualError', 'Style', 'assert_approx_column_equality', 'assert_approx_df_equality', 'assert_basic_rows_equality', 'assert_column_equality', 'assert_df_equality')</code>  <code>module-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Chispa","title":"<code>Chispa</code>","text":"Source code in <code>chispa/__init__.py</code> <pre><code>class Chispa:\n    def __init__(self, formats: FormattingConfig | None = None) -&gt; None:\n        if not formats:\n            self.formats = FormattingConfig()\n        elif isinstance(formats, FormattingConfig):\n            self.formats = formats\n        else:\n            self.formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    def assert_df_equality(\n        self,\n        df1: DataFrame,\n        df2: DataFrame,\n        ignore_nullable: bool = False,\n        transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n        allow_nan_equality: bool = False,\n        ignore_column_order: bool = False,\n        ignore_row_order: bool = False,\n        underline_cells: bool = False,\n        ignore_metadata: bool = False,\n        ignore_columns: list[str] | None = None,\n    ) -&gt; None:\n        return assert_df_equality(\n            df1,\n            df2,\n            ignore_nullable,\n            transforms,\n            allow_nan_equality,\n            ignore_column_order,\n            ignore_row_order,\n            underline_cells,\n            ignore_metadata,\n            ignore_columns,\n            self.formats,\n        )\n</code></pre>"},{"location":"reference/chispa/#chispa.Chispa.formats","title":"<code>formats = FormattingConfig()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Chispa.__init__","title":"<code>__init__(formats=None)</code>","text":"Source code in <code>chispa/__init__.py</code> <pre><code>def __init__(self, formats: FormattingConfig | None = None) -&gt; None:\n    if not formats:\n        self.formats = FormattingConfig()\n    elif isinstance(formats, FormattingConfig):\n        self.formats = formats\n    else:\n        self.formats = FormattingConfig._from_arbitrary_dataclass(formats)\n</code></pre>"},{"location":"reference/chispa/#chispa.Chispa.assert_df_equality","title":"<code>assert_df_equality(df1, df2, ignore_nullable=False, transforms=None, allow_nan_equality=False, ignore_column_order=False, ignore_row_order=False, underline_cells=False, ignore_metadata=False, ignore_columns=None)</code>","text":"Source code in <code>chispa/__init__.py</code> <pre><code>def assert_df_equality(\n    self,\n    df1: DataFrame,\n    df2: DataFrame,\n    ignore_nullable: bool = False,\n    transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n    allow_nan_equality: bool = False,\n    ignore_column_order: bool = False,\n    ignore_row_order: bool = False,\n    underline_cells: bool = False,\n    ignore_metadata: bool = False,\n    ignore_columns: list[str] | None = None,\n) -&gt; None:\n    return assert_df_equality(\n        df1,\n        df2,\n        ignore_nullable,\n        transforms,\n        allow_nan_equality,\n        ignore_column_order,\n        ignore_row_order,\n        underline_cells,\n        ignore_metadata,\n        ignore_columns,\n        self.formats,\n    )\n</code></pre>"},{"location":"reference/chispa/#chispa.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/#chispa.Color.BLACK","title":"<code>BLACK = '\\x1b[30m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.BLUE","title":"<code>BLUE = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.CYAN","title":"<code>CYAN = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.DARK_GRAY","title":"<code>DARK_GRAY = '\\x1b[90m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.GREEN","title":"<code>GREEN = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_BLUE","title":"<code>LIGHT_BLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_CYAN","title":"<code>LIGHT_CYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_GRAY","title":"<code>LIGHT_GRAY = '\\x1b[37m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_GREEN","title":"<code>LIGHT_GREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_PURPLE","title":"<code>LIGHT_PURPLE = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_RED","title":"<code>LIGHT_RED = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.LIGHT_YELLOW","title":"<code>LIGHT_YELLOW = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.PURPLE","title":"<code>PURPLE = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.RED","title":"<code>RED = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.WHITE","title":"<code>WHITE = '\\x1b[97m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Color.YELLOW","title":"<code>YELLOW = '\\x1b[33m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.ColumnsNotEqualError","title":"<code>ColumnsNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The columns are not equal</p> Source code in <code>chispa/column_comparer.py</code> <pre><code>class ColumnsNotEqualError(Exception):\n    \"\"\"The columns are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/#chispa.DataFramesNotEqualError","title":"<code>DataFramesNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The DataFrames are not equal</p> Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>class DataFramesNotEqualError(Exception):\n    \"\"\"The DataFrames are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/#chispa.DefaultFormats","title":"<code>DefaultFormats</code>  <code>dataclass</code>","text":"<p>This class is now deprecated and should be removed in a future release.</p> Source code in <code>chispa/default_formats.py</code> <pre><code>@dataclass\nclass DefaultFormats:\n    \"\"\"\n    This class is now deprecated and should be removed in a future release.\n    \"\"\"\n\n    mismatched_rows: list[str] = field(default_factory=lambda: [\"red\"])\n    matched_rows: list[str] = field(default_factory=lambda: [\"blue\"])\n    mismatched_cells: list[str] = field(default_factory=lambda: [\"red\", \"underline\"])\n    matched_cells: list[str] = field(default_factory=lambda: [\"blue\"])\n\n    def __post_init__(self) -&gt; None:\n        warnings.warn(\n            \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n        )\n</code></pre>"},{"location":"reference/chispa/#chispa.DefaultFormats.matched_cells","title":"<code>matched_cells = field(default_factory=lambda: ['blue'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.DefaultFormats.matched_rows","title":"<code>matched_rows = field(default_factory=lambda: ['blue'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.DefaultFormats.mismatched_cells","title":"<code>mismatched_cells = field(default_factory=lambda: ['red', 'underline'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.DefaultFormats.mismatched_rows","title":"<code>mismatched_rows = field(default_factory=lambda: ['red'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.DefaultFormats.__init__","title":"<code>__init__(mismatched_rows=lambda: ['red'](), matched_rows=lambda: ['blue'](), mismatched_cells=lambda: ['red', 'underline'](), matched_cells=lambda: ['blue']())</code>","text":""},{"location":"reference/chispa/#chispa.DefaultFormats.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>chispa/default_formats.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    warnings.warn(\n        \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n    )\n</code></pre>"},{"location":"reference/chispa/#chispa.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/#chispa.Format.color","title":"<code>color = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Format.style","title":"<code>style = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Format.__init__","title":"<code>__init__(color=None, style=None)</code>","text":""},{"location":"reference/chispa/#chispa.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/#chispa.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/#chispa.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/#chispa.FormattingConfig.VALID_KEYS","title":"<code>VALID_KEYS = {'color', 'style'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.FormattingConfig.matched_cells","title":"<code>matched_cells = self._parse_format(matched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.FormattingConfig.matched_rows","title":"<code>matched_rows = self._parse_format(matched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.FormattingConfig.mismatched_cells","title":"<code>mismatched_cells = self._parse_format(mismatched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.FormattingConfig.mismatched_rows","title":"<code>mismatched_rows = self._parse_format(mismatched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"},{"location":"reference/chispa/#chispa.SchemasNotEqualError","title":"<code>SchemasNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The schemas are not equal</p> Source code in <code>chispa/schema_comparer.py</code> <pre><code>class SchemasNotEqualError(Exception):\n    \"\"\"The schemas are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/#chispa.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/#chispa.Style.BLINK","title":"<code>BLINK = '\\x1b[5m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Style.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Style.HIDE","title":"<code>HIDE = '\\x1b[8m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Style.INVERT","title":"<code>INVERT = '\\x1b[7m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.Style.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/#chispa.assert_approx_column_equality","title":"<code>assert_approx_column_equality(df, col_name1, col_name2, precision)</code>","text":"Source code in <code>chispa/column_comparer.py</code> <pre><code>def assert_approx_column_equality(df: DataFrame, col_name1: str, col_name2: str, precision: float) -&gt; None:\n    rows = df.select(col_name1, col_name2).collect()\n    col_name_1_elements = [x[0] for x in rows]\n    col_name_2_elements = [x[1] for x in rows]\n    all_rows_equal = True\n    zipped = list(zip(col_name_1_elements, col_name_2_elements))\n    t = PrettyTable([col_name1, col_name2])\n    for elements in zipped:\n        first = blue(str(elements[0]))\n        second = blue(str(elements[1]))\n        # when one is None and the other isn't, they're not equal\n        if (elements[0] is None) != (elements[1] is None):\n            all_rows_equal = False\n            t.add_row([str(elements[0]), str(elements[1])])\n        # when both are None, they're equal\n        elif elements[0] is None and elements[1] is None:\n            t.add_row([first, second])\n        # when the diff is less than the threshhold, they're approximately equal\n        elif abs(elements[0] - elements[1]) &lt; precision:\n            t.add_row([first, second])\n        # otherwise, they're not equal\n        else:\n            all_rows_equal = False\n            t.add_row([str(elements[0]), str(elements[1])])\n    if all_rows_equal is False:\n        raise ColumnsNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/#chispa.assert_approx_df_equality","title":"<code>assert_approx_df_equality(df1, df2, precision, ignore_nullable=False, transforms=None, allow_nan_equality=False, ignore_column_order=False, ignore_row_order=False, ignore_columns=None, formats=None)</code>","text":"Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>def assert_approx_df_equality(\n    df1: DataFrame,\n    df2: DataFrame,\n    precision: float,\n    ignore_nullable: bool = False,\n    transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n    allow_nan_equality: bool = False,\n    ignore_column_order: bool = False,\n    ignore_row_order: bool = False,\n    ignore_columns: list[str] | None = None,\n    formats: FormattingConfig | None = None,\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if transforms is None:\n        transforms = []\n    if ignore_column_order:\n        transforms.append(lambda df: df.select(sorted(df.columns)))\n    if ignore_columns:\n        transforms.append(lambda df: df.drop(*ignore_columns))\n    if ignore_row_order:\n        transforms.append(lambda df: df.sort(df.columns))\n\n    df1 = reduce(lambda acc, fn: fn(acc), transforms, df1)\n    df2 = reduce(lambda acc, fn: fn(acc), transforms, df2)\n\n    assert_schema_equality(df1.schema, df2.schema, ignore_nullable)\n\n    if precision != 0:\n        assert_generic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            are_rows_approx_equal,\n            {\"precision\": precision, \"allow_nan_equality\": allow_nan_equality},\n            formats=formats,\n        )\n    elif allow_nan_equality:\n        assert_generic_rows_equality(\n            df1.collect(), df2.collect(), are_rows_equal_enhanced, {\"allow_nan_equality\": True}, formats=formats\n        )\n    else:\n        assert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre>"},{"location":"reference/chispa/#chispa.assert_basic_rows_equality","title":"<code>assert_basic_rows_equality(rows1, rows2, underline_cells=False, formats=None)</code>","text":"Source code in <code>chispa/rows_comparer.py</code> <pre><code>def assert_basic_rows_equality(\n    rows1: list[Row], rows2: list[Row], underline_cells: bool = False, formats: FormattingConfig | None = None\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if rows1 != rows2:\n        t = PrettyTable([\"df1\", \"df2\"])\n        zipped = list(zip_longest(rows1, rows2))\n        all_rows_equal = True\n\n        for r1, r2 in zipped:\n            if r1 is None and r2 is not None:\n                t.add_row([None, format_string(str(r2), formats.mismatched_rows)])\n                all_rows_equal = False\n            elif r1 is not None and r2 is None:\n                t.add_row([format_string(str(r1), formats.mismatched_rows), None])\n                all_rows_equal = False\n            else:\n                r_zipped = list(zip_longest(r1.__fields__, r2.__fields__))\n                r1_string = []\n                r2_string = []\n                for r1_field, r2_field in r_zipped:\n                    if r1[r1_field] != r2[r2_field]:\n                        all_rows_equal = False\n                        r1_string.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.mismatched_cells))\n                        r2_string.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.mismatched_cells))\n                    else:\n                        r1_string.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.matched_cells))\n                        r2_string.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.matched_cells))\n                r1_res = \", \".join(r1_string)\n                r2_res = \", \".join(r2_string)\n\n                t.add_row([r1_res, r2_res])\n        if all_rows_equal is False:\n            raise chispa.DataFramesNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/#chispa.assert_column_equality","title":"<code>assert_column_equality(df, col_name1, col_name2)</code>","text":"Source code in <code>chispa/column_comparer.py</code> <pre><code>def assert_column_equality(df: DataFrame, col_name1: str, col_name2: str) -&gt; None:\n    rows = df.select(col_name1, col_name2).collect()\n    col_name_1_elements = [x[0] for x in rows]\n    col_name_2_elements = [x[1] for x in rows]\n    if col_name_1_elements != col_name_2_elements:\n        zipped = list(zip(col_name_1_elements, col_name_2_elements))\n        t = PrettyTable([col_name1, col_name2])\n        for elements in zipped:\n            if elements[0] == elements[1]:\n                t.add_row([blue(str(elements[0])), blue(str(elements[1]))])\n            else:\n                t.add_row([str(elements[0]), str(elements[1])])\n        raise ColumnsNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/#chispa.assert_df_equality","title":"<code>assert_df_equality(df1, df2, ignore_nullable=False, transforms=None, allow_nan_equality=False, ignore_column_order=False, ignore_row_order=False, underline_cells=False, ignore_metadata=False, ignore_columns=None, formats=None)</code>","text":"Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>def assert_df_equality(\n    df1: DataFrame,\n    df2: DataFrame,\n    ignore_nullable: bool = False,\n    transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n    allow_nan_equality: bool = False,\n    ignore_column_order: bool = False,\n    ignore_row_order: bool = False,\n    underline_cells: bool = False,\n    ignore_metadata: bool = False,\n    ignore_columns: list[str] | None = None,\n    formats: FormattingConfig | None = None,\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if transforms is None:\n        transforms = []\n    if ignore_column_order:\n        transforms.append(lambda df: df.select(sorted(df.columns)))\n    if ignore_columns:\n        transforms.append(lambda df: df.drop(*ignore_columns))\n    if ignore_row_order:\n        transforms.append(lambda df: df.sort(df.columns))\n\n    df1 = reduce(lambda acc, fn: fn(acc), transforms, df1)\n    df2 = reduce(lambda acc, fn: fn(acc), transforms, df2)\n\n    assert_schema_equality(df1.schema, df2.schema, ignore_nullable, ignore_metadata)\n\n    if allow_nan_equality:\n        assert_generic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            are_rows_equal_enhanced,\n            {\"allow_nan_equality\": True},\n            underline_cells=underline_cells,\n            formats=formats,\n        )\n    else:\n        assert_basic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            underline_cells=underline_cells,\n            formats=formats,\n        )\n</code></pre>"},{"location":"reference/chispa/bcolors/","title":"Bcolors","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors","title":"<code>bcolors</code>","text":"Source code in <code>chispa/bcolors.py</code> <pre><code>class bcolors:\n    NC = \"\\033[0m\"  # No Color, reset all\n\n    Bold = \"\\033[1m\"\n    Underlined = \"\\033[4m\"\n    Blink = \"\\033[5m\"\n    Inverted = \"\\033[7m\"\n    Hidden = \"\\033[8m\"\n\n    Black = \"\\033[30m\"\n    Red = \"\\033[31m\"\n    Green = \"\\033[32m\"\n    Yellow = \"\\033[33m\"\n    Blue = \"\\033[34m\"\n    Purple = \"\\033[35m\"\n    Cyan = \"\\033[36m\"\n    LightGray = \"\\033[37m\"\n    DarkGray = \"\\033[30m\"\n    LightRed = \"\\033[31m\"\n    LightGreen = \"\\033[32m\"\n    LightYellow = \"\\033[93m\"\n    LightBlue = \"\\033[34m\"\n    LightPurple = \"\\033[35m\"\n    LightCyan = \"\\033[36m\"\n    White = \"\\033[97m\"\n\n    # Style\n    Bold = \"\\033[1m\"\n    Underline = \"\\033[4m\"\n\n    def __init__(self) -&gt; None:\n        warnings.warn(\"The `bcolors` class is deprecated and will be removed in a future version.\", DeprecationWarning)\n</code></pre>"},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Black","title":"<code>Black = '\\x1b[30m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Blink","title":"<code>Blink = '\\x1b[5m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Blue","title":"<code>Blue = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Bold","title":"<code>Bold = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Cyan","title":"<code>Cyan = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.DarkGray","title":"<code>DarkGray = '\\x1b[30m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Green","title":"<code>Green = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Hidden","title":"<code>Hidden = '\\x1b[8m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Inverted","title":"<code>Inverted = '\\x1b[7m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightBlue","title":"<code>LightBlue = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightCyan","title":"<code>LightCyan = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightGray","title":"<code>LightGray = '\\x1b[37m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightGreen","title":"<code>LightGreen = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightPurple","title":"<code>LightPurple = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightRed","title":"<code>LightRed = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.LightYellow","title":"<code>LightYellow = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.NC","title":"<code>NC = '\\x1b[0m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Purple","title":"<code>Purple = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Red","title":"<code>Red = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Underline","title":"<code>Underline = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Underlined","title":"<code>Underlined = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.White","title":"<code>White = '\\x1b[97m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.Yellow","title":"<code>Yellow = '\\x1b[33m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/bcolors/#chispa.bcolors.bcolors.__init__","title":"<code>__init__()</code>","text":"Source code in <code>chispa/bcolors.py</code> <pre><code>def __init__(self) -&gt; None:\n    warnings.warn(\"The `bcolors` class is deprecated and will be removed in a future version.\", DeprecationWarning)\n</code></pre>"},{"location":"reference/chispa/bcolors/#chispa.bcolors.blue","title":"<code>blue(s)</code>","text":"Source code in <code>chispa/bcolors.py</code> <pre><code>def blue(s: str) -&gt; str:\n    warnings.warn(\"The `blue` function is deprecated and will be removed in a future version.\", DeprecationWarning)\n    return bcolors.LightBlue + str(s) + bcolors.LightRed\n</code></pre>"},{"location":"reference/chispa/bcolors/#chispa.bcolors.line_blue","title":"<code>line_blue(s)</code>","text":"Source code in <code>chispa/bcolors.py</code> <pre><code>def line_blue(s: str) -&gt; str:\n    return bcolors.LightBlue + s + bcolors.NC\n</code></pre>"},{"location":"reference/chispa/bcolors/#chispa.bcolors.line_red","title":"<code>line_red(s)</code>","text":"Source code in <code>chispa/bcolors.py</code> <pre><code>def line_red(s: str) -&gt; str:\n    return bcolors.LightRed + s + bcolors.NC\n</code></pre>"},{"location":"reference/chispa/bcolors/#chispa.bcolors.underline_text","title":"<code>underline_text(input_text)</code>","text":"<p>Takes an input string and returns a white, underlined string (based on PrettyTable formatting)</p> Source code in <code>chispa/bcolors.py</code> <pre><code>def underline_text(input_text: str) -&gt; str:\n    \"\"\"\n    Takes an input string and returns a white, underlined string (based on PrettyTable formatting)\n    \"\"\"\n    warnings.warn(\n        \"The `underline_text` function is deprecated and will be removed in a future version.\", DeprecationWarning\n    )\n    return bcolors.White + bcolors.Underline + input_text + bcolors.NC + bcolors.LightRed\n</code></pre>"},{"location":"reference/chispa/column_comparer/","title":"Column comparer","text":""},{"location":"reference/chispa/column_comparer/#chispa.column_comparer.ColumnsNotEqualError","title":"<code>ColumnsNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The columns are not equal</p> Source code in <code>chispa/column_comparer.py</code> <pre><code>class ColumnsNotEqualError(Exception):\n    \"\"\"The columns are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/column_comparer/#chispa.column_comparer.assert_approx_column_equality","title":"<code>assert_approx_column_equality(df, col_name1, col_name2, precision)</code>","text":"Source code in <code>chispa/column_comparer.py</code> <pre><code>def assert_approx_column_equality(df: DataFrame, col_name1: str, col_name2: str, precision: float) -&gt; None:\n    rows = df.select(col_name1, col_name2).collect()\n    col_name_1_elements = [x[0] for x in rows]\n    col_name_2_elements = [x[1] for x in rows]\n    all_rows_equal = True\n    zipped = list(zip(col_name_1_elements, col_name_2_elements))\n    t = PrettyTable([col_name1, col_name2])\n    for elements in zipped:\n        first = blue(str(elements[0]))\n        second = blue(str(elements[1]))\n        # when one is None and the other isn't, they're not equal\n        if (elements[0] is None) != (elements[1] is None):\n            all_rows_equal = False\n            t.add_row([str(elements[0]), str(elements[1])])\n        # when both are None, they're equal\n        elif elements[0] is None and elements[1] is None:\n            t.add_row([first, second])\n        # when the diff is less than the threshhold, they're approximately equal\n        elif abs(elements[0] - elements[1]) &lt; precision:\n            t.add_row([first, second])\n        # otherwise, they're not equal\n        else:\n            all_rows_equal = False\n            t.add_row([str(elements[0]), str(elements[1])])\n    if all_rows_equal is False:\n        raise ColumnsNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/column_comparer/#chispa.column_comparer.assert_column_equality","title":"<code>assert_column_equality(df, col_name1, col_name2)</code>","text":"Source code in <code>chispa/column_comparer.py</code> <pre><code>def assert_column_equality(df: DataFrame, col_name1: str, col_name2: str) -&gt; None:\n    rows = df.select(col_name1, col_name2).collect()\n    col_name_1_elements = [x[0] for x in rows]\n    col_name_2_elements = [x[1] for x in rows]\n    if col_name_1_elements != col_name_2_elements:\n        zipped = list(zip(col_name_1_elements, col_name_2_elements))\n        t = PrettyTable([col_name1, col_name2])\n        for elements in zipped:\n            if elements[0] == elements[1]:\n                t.add_row([blue(str(elements[0])), blue(str(elements[1]))])\n            else:\n                t.add_row([str(elements[0]), str(elements[1])])\n        raise ColumnsNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/common_enums/","title":"Common enums","text":""},{"location":"reference/chispa/common_enums/#chispa.common_enums.OutputFormat","title":"<code>OutputFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>chispa/common_enums.py</code> <pre><code>class OutputFormat(str, Enum):\n    TABLE = \"table\"\n    TREE = \"tree\"\n</code></pre>"},{"location":"reference/chispa/common_enums/#chispa.common_enums.OutputFormat.TABLE","title":"<code>TABLE = 'table'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/common_enums/#chispa.common_enums.OutputFormat.TREE","title":"<code>TREE = 'tree'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/common_enums/#chispa.common_enums.TypeName","title":"<code>TypeName</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>chispa/common_enums.py</code> <pre><code>class TypeName(str, Enum):\n    ARRAY = \"array\"\n    STRUCT = \"struct\"\n</code></pre>"},{"location":"reference/chispa/common_enums/#chispa.common_enums.TypeName.ARRAY","title":"<code>ARRAY = 'array'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/common_enums/#chispa.common_enums.TypeName.STRUCT","title":"<code>STRUCT = 'struct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/dataframe_comparer/","title":"Dataframe comparer","text":""},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.DataFramesNotEqualError","title":"<code>DataFramesNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The DataFrames are not equal</p> Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>class DataFramesNotEqualError(Exception):\n    \"\"\"The DataFrames are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.are_dfs_equal","title":"<code>are_dfs_equal(df1, df2)</code>","text":"Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>def are_dfs_equal(df1: DataFrame, df2: DataFrame) -&gt; bool:\n    if df1.schema != df2.schema:\n        return False\n    if df1.collect() != df2.collect():\n        return False\n    return True\n</code></pre>"},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.assert_approx_df_equality","title":"<code>assert_approx_df_equality(df1, df2, precision, ignore_nullable=False, transforms=None, allow_nan_equality=False, ignore_column_order=False, ignore_row_order=False, ignore_columns=None, formats=None)</code>","text":"Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>def assert_approx_df_equality(\n    df1: DataFrame,\n    df2: DataFrame,\n    precision: float,\n    ignore_nullable: bool = False,\n    transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n    allow_nan_equality: bool = False,\n    ignore_column_order: bool = False,\n    ignore_row_order: bool = False,\n    ignore_columns: list[str] | None = None,\n    formats: FormattingConfig | None = None,\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if transforms is None:\n        transforms = []\n    if ignore_column_order:\n        transforms.append(lambda df: df.select(sorted(df.columns)))\n    if ignore_columns:\n        transforms.append(lambda df: df.drop(*ignore_columns))\n    if ignore_row_order:\n        transforms.append(lambda df: df.sort(df.columns))\n\n    df1 = reduce(lambda acc, fn: fn(acc), transforms, df1)\n    df2 = reduce(lambda acc, fn: fn(acc), transforms, df2)\n\n    assert_schema_equality(df1.schema, df2.schema, ignore_nullable)\n\n    if precision != 0:\n        assert_generic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            are_rows_approx_equal,\n            {\"precision\": precision, \"allow_nan_equality\": allow_nan_equality},\n            formats=formats,\n        )\n    elif allow_nan_equality:\n        assert_generic_rows_equality(\n            df1.collect(), df2.collect(), are_rows_equal_enhanced, {\"allow_nan_equality\": True}, formats=formats\n        )\n    else:\n        assert_basic_rows_equality(df1.collect(), df2.collect(), formats=formats)\n</code></pre>"},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.assert_df_equality","title":"<code>assert_df_equality(df1, df2, ignore_nullable=False, transforms=None, allow_nan_equality=False, ignore_column_order=False, ignore_row_order=False, underline_cells=False, ignore_metadata=False, ignore_columns=None, formats=None)</code>","text":"Source code in <code>chispa/dataframe_comparer.py</code> <pre><code>def assert_df_equality(\n    df1: DataFrame,\n    df2: DataFrame,\n    ignore_nullable: bool = False,\n    transforms: list[Callable] | None = None,  # type: ignore[type-arg]\n    allow_nan_equality: bool = False,\n    ignore_column_order: bool = False,\n    ignore_row_order: bool = False,\n    underline_cells: bool = False,\n    ignore_metadata: bool = False,\n    ignore_columns: list[str] | None = None,\n    formats: FormattingConfig | None = None,\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if transforms is None:\n        transforms = []\n    if ignore_column_order:\n        transforms.append(lambda df: df.select(sorted(df.columns)))\n    if ignore_columns:\n        transforms.append(lambda df: df.drop(*ignore_columns))\n    if ignore_row_order:\n        transforms.append(lambda df: df.sort(df.columns))\n\n    df1 = reduce(lambda acc, fn: fn(acc), transforms, df1)\n    df2 = reduce(lambda acc, fn: fn(acc), transforms, df2)\n\n    assert_schema_equality(df1.schema, df2.schema, ignore_nullable, ignore_metadata)\n\n    if allow_nan_equality:\n        assert_generic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            are_rows_equal_enhanced,\n            {\"allow_nan_equality\": True},\n            underline_cells=underline_cells,\n            formats=formats,\n        )\n    else:\n        assert_basic_rows_equality(\n            df1.collect(),\n            df2.collect(),\n            underline_cells=underline_cells,\n            formats=formats,\n        )\n</code></pre>"},{"location":"reference/chispa/default_formats/","title":"Default formats","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats","title":"<code>DefaultFormats</code>  <code>dataclass</code>","text":"<p>This class is now deprecated and should be removed in a future release.</p> Source code in <code>chispa/default_formats.py</code> <pre><code>@dataclass\nclass DefaultFormats:\n    \"\"\"\n    This class is now deprecated and should be removed in a future release.\n    \"\"\"\n\n    mismatched_rows: list[str] = field(default_factory=lambda: [\"red\"])\n    matched_rows: list[str] = field(default_factory=lambda: [\"blue\"])\n    mismatched_cells: list[str] = field(default_factory=lambda: [\"red\", \"underline\"])\n    matched_cells: list[str] = field(default_factory=lambda: [\"blue\"])\n\n    def __post_init__(self) -&gt; None:\n        warnings.warn(\n            \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n        )\n</code></pre>"},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.matched_cells","title":"<code>matched_cells = field(default_factory=lambda: ['blue'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.matched_rows","title":"<code>matched_rows = field(default_factory=lambda: ['blue'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.mismatched_cells","title":"<code>mismatched_cells = field(default_factory=lambda: ['red', 'underline'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.mismatched_rows","title":"<code>mismatched_rows = field(default_factory=lambda: ['red'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.__init__","title":"<code>__init__(mismatched_rows=lambda: ['red'](), matched_rows=lambda: ['blue'](), mismatched_cells=lambda: ['red', 'underline'](), matched_cells=lambda: ['blue']())</code>","text":""},{"location":"reference/chispa/default_formats/#chispa.default_formats.DefaultFormats.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>chispa/default_formats.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    warnings.warn(\n        \"DefaultFormats is deprecated. Use `chispa.formatting.FormattingConfig` instead.\", DeprecationWarning\n    )\n</code></pre>"},{"location":"reference/chispa/number_helpers/","title":"Number helpers","text":""},{"location":"reference/chispa/number_helpers/#chispa.number_helpers.isnan","title":"<code>isnan(x)</code>","text":"Source code in <code>chispa/number_helpers.py</code> <pre><code>def isnan(x: Any) -&gt; bool:\n    try:\n        return math.isnan(x)\n    except TypeError:\n        return False\n</code></pre>"},{"location":"reference/chispa/number_helpers/#chispa.number_helpers.nan_safe_approx_equality","title":"<code>nan_safe_approx_equality(x, y, precision)</code>","text":"Source code in <code>chispa/number_helpers.py</code> <pre><code>def nan_safe_approx_equality(x: int | float, y: int | float, precision: float | Decimal) -&gt; bool:\n    return (abs(x - y) &lt;= precision) or (isnan(x) and isnan(y))\n</code></pre>"},{"location":"reference/chispa/number_helpers/#chispa.number_helpers.nan_safe_equality","title":"<code>nan_safe_equality(x, y)</code>","text":"Source code in <code>chispa/number_helpers.py</code> <pre><code>def nan_safe_equality(x: int | float, y: int | float | Decimal) -&gt; bool:\n    return (x == y) or (isnan(x) and isnan(y))\n</code></pre>"},{"location":"reference/chispa/row_comparer/","title":"Row comparer","text":""},{"location":"reference/chispa/row_comparer/#chispa.row_comparer.are_rows_approx_equal","title":"<code>are_rows_approx_equal(r1, r2, precision, allow_nan_equality=False)</code>","text":"Source code in <code>chispa/row_comparer.py</code> <pre><code>def are_rows_approx_equal(r1: Row | None, r2: Row | None, precision: float, allow_nan_equality: bool = False) -&gt; bool:\n    if r1 is None and r2 is None:\n        return True\n    if r1 is None or r2 is None:\n        return False\n    d1 = r1.asDict()\n    d2 = r2.asDict()\n    allEqual = True\n    for key in d1.keys() &amp; d2.keys():\n        if isinstance(d1[key], float) and isinstance(d2[key], float):\n            if allow_nan_equality and not (nan_safe_approx_equality(d1[key], d2[key], precision)):\n                allEqual = False\n            elif not (allow_nan_equality) and math.isnan(abs(d1[key] - d2[key])):\n                allEqual = False\n            elif abs(d1[key] - d2[key]) &gt; precision:\n                allEqual = False\n        elif d1[key] != d2[key]:\n            allEqual = False\n    return allEqual\n</code></pre>"},{"location":"reference/chispa/row_comparer/#chispa.row_comparer.are_rows_equal","title":"<code>are_rows_equal(r1, r2)</code>","text":"Source code in <code>chispa/row_comparer.py</code> <pre><code>def are_rows_equal(r1: Row, r2: Row) -&gt; bool:\n    return r1 == r2\n</code></pre>"},{"location":"reference/chispa/row_comparer/#chispa.row_comparer.are_rows_equal_enhanced","title":"<code>are_rows_equal_enhanced(r1, r2, allow_nan_equality)</code>","text":"Source code in <code>chispa/row_comparer.py</code> <pre><code>def are_rows_equal_enhanced(r1: Row | None, r2: Row | None, allow_nan_equality: bool) -&gt; bool:\n    if r1 is None and r2 is None:\n        return True\n    if r1 is None or r2 is None:\n        return False\n    d1 = r1.asDict()\n    d2 = r2.asDict()\n    if allow_nan_equality:\n        for key in d1.keys() &amp; d2.keys():\n            if not (nan_safe_equality(d1[key], d2[key])):\n                return False\n        return True\n    else:\n        return r1 == r2\n</code></pre>"},{"location":"reference/chispa/rows_comparer/","title":"Rows comparer","text":""},{"location":"reference/chispa/rows_comparer/#chispa.rows_comparer.assert_basic_rows_equality","title":"<code>assert_basic_rows_equality(rows1, rows2, underline_cells=False, formats=None)</code>","text":"Source code in <code>chispa/rows_comparer.py</code> <pre><code>def assert_basic_rows_equality(\n    rows1: list[Row], rows2: list[Row], underline_cells: bool = False, formats: FormattingConfig | None = None\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    if rows1 != rows2:\n        t = PrettyTable([\"df1\", \"df2\"])\n        zipped = list(zip_longest(rows1, rows2))\n        all_rows_equal = True\n\n        for r1, r2 in zipped:\n            if r1 is None and r2 is not None:\n                t.add_row([None, format_string(str(r2), formats.mismatched_rows)])\n                all_rows_equal = False\n            elif r1 is not None and r2 is None:\n                t.add_row([format_string(str(r1), formats.mismatched_rows), None])\n                all_rows_equal = False\n            else:\n                r_zipped = list(zip_longest(r1.__fields__, r2.__fields__))\n                r1_string = []\n                r2_string = []\n                for r1_field, r2_field in r_zipped:\n                    if r1[r1_field] != r2[r2_field]:\n                        all_rows_equal = False\n                        r1_string.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.mismatched_cells))\n                        r2_string.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.mismatched_cells))\n                    else:\n                        r1_string.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.matched_cells))\n                        r2_string.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.matched_cells))\n                r1_res = \", \".join(r1_string)\n                r2_res = \", \".join(r2_string)\n\n                t.add_row([r1_res, r2_res])\n        if all_rows_equal is False:\n            raise chispa.DataFramesNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/rows_comparer/#chispa.rows_comparer.assert_generic_rows_equality","title":"<code>assert_generic_rows_equality(rows1, rows2, row_equality_fun, row_equality_fun_args, underline_cells=False, formats=None)</code>","text":"Source code in <code>chispa/rows_comparer.py</code> <pre><code>def assert_generic_rows_equality(\n    rows1: list[Row],\n    rows2: list[Row],\n    row_equality_fun: Callable,  # type: ignore[type-arg]\n    row_equality_fun_args: dict[str, Any],\n    underline_cells: bool = False,\n    formats: FormattingConfig | None = None,\n) -&gt; None:\n    if not formats:\n        formats = FormattingConfig()\n    elif not isinstance(formats, FormattingConfig):\n        formats = FormattingConfig._from_arbitrary_dataclass(formats)\n\n    df1_rows = rows1\n    df2_rows = rows2\n    zipped = list(zip_longest(df1_rows, df2_rows))\n    t = PrettyTable([\"df1\", \"df2\"])\n    all_rows_equal = True\n    for r1, r2 in zipped:\n        # rows are not equal when one is None and the other isn't\n        if (r1 is None) ^ (r2 is None):\n            all_rows_equal = False\n            t.add_row([\n                format_string(str(r1), formats.mismatched_rows),\n                format_string(str(r2), formats.mismatched_rows),\n            ])\n        # rows are equal\n        elif row_equality_fun(r1, r2, **row_equality_fun_args):\n            r1_string = \", \".join(map(lambda f: f\"{f}={r1[f]}\", r1.__fields__))\n            r2_string = \", \".join(map(lambda f: f\"{f}={r2[f]}\", r2.__fields__))\n            t.add_row([\n                format_string(r1_string, formats.matched_rows),\n                format_string(r2_string, formats.matched_rows),\n            ])\n        # otherwise, rows aren't equal\n        else:\n            r_zipped = list(zip_longest(r1.__fields__, r2.__fields__))\n            r1_string_list: list[str] = []\n            r2_string_list: list[str] = []\n            for r1_field, r2_field in r_zipped:\n                if r1[r1_field] != r2[r2_field]:\n                    all_rows_equal = False\n                    r1_string_list.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.mismatched_cells))\n                    r2_string_list.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.mismatched_cells))\n                else:\n                    r1_string_list.append(format_string(f\"{r1_field}={r1[r1_field]}\", formats.matched_cells))\n                    r2_string_list.append(format_string(f\"{r2_field}={r2[r2_field]}\", formats.matched_cells))\n            r1_res = \", \".join(r1_string_list)\n            r2_res = \", \".join(r2_string_list)\n\n            t.add_row([r1_res, r2_res])\n    if all_rows_equal is False:\n        raise chispa.DataFramesNotEqualError(\"\\n\" + t.get_string())\n</code></pre>"},{"location":"reference/chispa/schema_comparer/","title":"Schema comparer","text":""},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.SchemasNotEqualError","title":"<code>SchemasNotEqualError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The schemas are not equal</p> Source code in <code>chispa/schema_comparer.py</code> <pre><code>class SchemasNotEqualError(Exception):\n    \"\"\"The schemas are not equal\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.are_datatypes_equal_ignore_nullable","title":"<code>are_datatypes_equal_ignore_nullable(dt1, dt2, ignore_metadata=False)</code>","text":"<p>Checks if datatypes are equal, descending into structs and arrays to ignore nullability.</p> Source code in <code>chispa/schema_comparer.py</code> <pre><code>@typing.no_type_check\ndef are_datatypes_equal_ignore_nullable(dt1, dt2, ignore_metadata: bool = False) -&gt; bool:\n    \"\"\"Checks if datatypes are equal, descending into structs and arrays to\n    ignore nullability.\n    \"\"\"\n    if dt1.typeName() == dt2.typeName():\n        # Account for array types by inspecting elementType.\n        if dt1.typeName() == TypeName.ARRAY:\n            return are_datatypes_equal_ignore_nullable(dt1.elementType, dt2.elementType, ignore_metadata)\n        elif dt1.typeName() == TypeName.STRUCT:\n            return are_schemas_equal_ignore_nullable(dt1, dt2, ignore_metadata)\n        else:\n            # Some data types have additional attributes (e.g. precision and scale for Decimal),\n            # and the type equality check must also check for equality of these attributes.\n            return vars(dt1) == vars(dt2)\n    else:\n        return False\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.are_schemas_equal_ignore_nullable","title":"<code>are_schemas_equal_ignore_nullable(s1, s2, ignore_metadata=False)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def are_schemas_equal_ignore_nullable(s1: StructType, s2: StructType, ignore_metadata: bool = False) -&gt; bool:\n    if len(s1) != len(s2):\n        return False\n    zipped = list(zip_longest(s1, s2))\n    for sf1, sf2 in zipped:\n        if not are_structfields_equal(sf1, sf2, True, ignore_metadata):\n            return False\n    return True\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.are_structfields_equal","title":"<code>are_structfields_equal(sf1, sf2, ignore_nullability=False, ignore_metadata=False)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def are_structfields_equal(\n    sf1: StructField | None, sf2: StructField | None, ignore_nullability: bool = False, ignore_metadata: bool = False\n) -&gt; bool:\n    if not ignore_nullability and not ignore_metadata:\n        return sf1 == sf2\n    else:\n        if sf1 is None or sf2 is None:\n            if sf1 is None and sf2 is None:\n                return True\n            else:\n                return False\n        if sf1.name != sf2.name:\n            return False\n        if not ignore_metadata and sf1.metadata != sf2.metadata:\n            return False\n        else:\n            return are_datatypes_equal_ignore_nullable(sf1.dataType, sf2.dataType, ignore_metadata)  # type: ignore[no-any-return, no-untyped-call]\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.assert_basic_schema_equality","title":"<code>assert_basic_schema_equality(s1, s2)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def assert_basic_schema_equality(s1: StructType, s2: StructType) -&gt; None:\n    if s1 != s2:\n        handle_schemas_not_equal(s1, s2, ignore_nullable=False, ignore_metadata=False)\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.assert_schema_equality","title":"<code>assert_schema_equality(s1, s2, ignore_nullable=False, ignore_metadata=False)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def assert_schema_equality(\n    s1: StructType, s2: StructType, ignore_nullable: bool = False, ignore_metadata: bool = False\n) -&gt; None:\n    if not ignore_nullable and not ignore_metadata:\n        assert_basic_schema_equality(s1, s2)\n    else:\n        assert_schema_equality_full(s1, s2, ignore_nullable, ignore_metadata)\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.assert_schema_equality_full","title":"<code>assert_schema_equality_full(s1, s2, ignore_nullable=False, ignore_metadata=False)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def assert_schema_equality_full(\n    s1: StructType, s2: StructType, ignore_nullable: bool = False, ignore_metadata: bool = False\n) -&gt; None:\n    def inner(s1: StructType, s2: StructType, ignore_nullable: bool, ignore_metadata: bool) -&gt; bool:\n        if len(s1) != len(s2):\n            return False\n        zipped = list(zip_longest(s1, s2))\n        for sf1, sf2 in zipped:\n            if not are_structfields_equal(sf1, sf2, ignore_nullable, ignore_metadata):\n                return False\n        return True\n\n    if not inner(s1, s2, ignore_nullable, ignore_metadata):\n        handle_schemas_not_equal(s1, s2, ignore_nullable, ignore_metadata)\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.assert_schema_equality_ignore_nullable","title":"<code>assert_schema_equality_ignore_nullable(s1, s2)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def assert_schema_equality_ignore_nullable(s1: StructType, s2: StructType) -&gt; None:\n    if not are_schemas_equal_ignore_nullable(s1, s2):\n        handle_schemas_not_equal(s1, s2, ignore_nullable=True, ignore_metadata=False)\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.check_if_schemas_are_wide","title":"<code>check_if_schemas_are_wide(s1, s2)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def check_if_schemas_are_wide(s1: StructType, s2: StructType) -&gt; bool:\n    contains_nested_structs = any(sf.dataType.typeName() == TypeName.STRUCT for sf in s1) or any(\n        sf.dataType.typeName() == TypeName.STRUCT for sf in s2\n    )\n    contains_many_columns = len(s1) &gt; 10 or len(s2) &gt; 10\n    return contains_nested_structs or contains_many_columns\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.create_schema_comparison_table","title":"<code>create_schema_comparison_table(s1, s2, ignore_nullable, ignore_metadata)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def create_schema_comparison_table(\n    s1: StructType, s2: StructType, ignore_nullable: bool, ignore_metadata: bool\n) -&gt; PrettyTable:\n    t = PrettyTable([\"schema1\", \"schema2\"])\n    zipped = list(zip_longest(s1, s2))\n    for sf1, sf2 in zipped:\n        if are_structfields_equal(sf1, sf2, ignore_nullable, ignore_metadata):\n            t.add_row([blue(str(sf1)), blue(str(sf2))])\n        else:\n            t.add_row([sf1, sf2])\n    return t\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.create_schema_comparison_tree","title":"<code>create_schema_comparison_tree(s1, s2, ignore_nullable, ignore_metadata)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def create_schema_comparison_tree(s1: StructType, s2: StructType, ignore_nullable: bool, ignore_metadata: bool) -&gt; str:\n    def parse_schema_as_tree(s: StructType, indent: int) -&gt; tuple[list[str], list[StructField]]:\n        tree_lines = []\n        fields = []\n\n        for struct_field in s:\n            nullable = \"(nullable = true)\" if struct_field.nullable else \"(nullable = false)\"\n            struct_field_type = struct_field.dataType.typeName()\n\n            struct_prefix = f\"{indent * ' '}|{'-' * 2}\"\n            struct_as_string = f\"{struct_field.name}: {struct_field_type} {nullable}\"\n\n            tree_lines += [f\"{struct_prefix} {struct_as_string}\"]\n\n            if not struct_field_type == TypeName.STRUCT:\n                fields += [struct_field]\n                continue\n\n            tree_line_nested, fields_nested = parse_schema_as_tree(struct_field.dataType, indent + 4)  # type: ignore[arg-type]\n\n            fields += [struct_field]\n            tree_lines += tree_line_nested\n            fields += fields_nested\n\n        return tree_lines, fields\n\n    tree_space = 6\n    s1_tree, s1_fields = parse_schema_as_tree(s1, 0)\n    s2_tree, s2_fields = parse_schema_as_tree(s2, 0)\n\n    widest_line = max(len(line) for line in s1_tree)\n    longest_tree = max(len(s1_tree), len(s2_tree))\n    schema_gap = widest_line + tree_space\n\n    tree = \"\\nschema1\".ljust(schema_gap) + \"schema2\\n\"\n    for i in range(longest_tree):\n        line1 = line2 = \"\"\n        s1_field = s2_field = None\n\n        if i &lt; len(s1_tree):\n            line1 = s1_tree[i]\n            s1_field = s1_fields[i]\n        if i &lt; len(s2_tree):\n            line2 = s2_tree[i]\n            s2_field = s2_fields[i]\n\n        tree_line = line1.ljust(schema_gap) + line2\n\n        if are_structfields_equal(s1_field, s2_field, ignore_nullable, ignore_metadata):\n            tree += line_blue(tree_line) + \"\\n\"\n        else:\n            tree += line_red(tree_line) + \"\\n\"\n\n    tree += bcolors.NC\n    return tree\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.handle_schemas_not_equal","title":"<code>handle_schemas_not_equal(s1, s2, ignore_nullable, ignore_metadata)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def handle_schemas_not_equal(s1: StructType, s2: StructType, ignore_nullable: bool, ignore_metadata: bool) -&gt; None:\n    schemas_are_wide = check_if_schemas_are_wide(s1, s2)\n    if schemas_are_wide:\n        error_message = create_schema_comparison_tree(s1, s2, ignore_nullable, ignore_metadata)\n    else:\n        t = create_schema_comparison_table(s1, s2, ignore_nullable, ignore_metadata)\n        error_message = \"\\n\" + t.get_string()\n    raise SchemasNotEqualError(error_message)\n</code></pre>"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.print_schema_diff","title":"<code>print_schema_diff(s1, s2, ignore_nullable, ignore_metadata, output_format=OutputFormat.TABLE)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def print_schema_diff(\n    s1: StructType,\n    s2: StructType,\n    ignore_nullable: bool,\n    ignore_metadata: bool,\n    output_format: OutputFormat = OutputFormat.TABLE,\n) -&gt; None:\n    if output_format == OutputFormat.TABLE:\n        schema_diff_table: PrettyTable = create_schema_comparison_table(s1, s2, ignore_nullable, ignore_metadata)\n        print(schema_diff_table)\n    elif output_format == OutputFormat.TREE:\n        schema_diff_tree: str = create_schema_comparison_tree(s1, s2, ignore_nullable, ignore_metadata)\n        print(schema_diff_tree)\n    else:\n        raise ValueError(f\"output_format must be one of {OutputFormat.__members__}\")\n</code></pre>"},{"location":"reference/chispa/structfield_comparer/","title":"Structfield comparer","text":""},{"location":"reference/chispa/structfield_comparer/#chispa.structfield_comparer.__all__","title":"<code>__all__ = ('are_structfields_equal',)</code>  <code>module-attribute</code>","text":""},{"location":"reference/chispa/structfield_comparer/#chispa.structfield_comparer.are_structfields_equal","title":"<code>are_structfields_equal(sf1, sf2, ignore_nullability=False, ignore_metadata=False)</code>","text":"Source code in <code>chispa/schema_comparer.py</code> <pre><code>def are_structfields_equal(\n    sf1: StructField | None, sf2: StructField | None, ignore_nullability: bool = False, ignore_metadata: bool = False\n) -&gt; bool:\n    if not ignore_nullability and not ignore_metadata:\n        return sf1 == sf2\n    else:\n        if sf1 is None or sf2 is None:\n            if sf1 is None and sf2 is None:\n                return True\n            else:\n                return False\n        if sf1.name != sf2.name:\n            return False\n        if not ignore_metadata and sf1.metadata != sf2.metadata:\n            return False\n        else:\n            return are_datatypes_equal_ignore_nullable(sf1.dataType, sf2.dataType, ignore_metadata)  # type: ignore[no-any-return, no-untyped-call]\n</code></pre>"},{"location":"reference/chispa/formatting/","title":"Index","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.RESET","title":"<code>RESET = '\\x1b[0m'</code>  <code>module-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.__all__","title":"<code>__all__ = ('RESET', 'Color', 'Format', 'FormattingConfig', 'Style', 'blue', 'format_string')</code>  <code>module-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Color.BLACK","title":"<code>BLACK = '\\x1b[30m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.BLUE","title":"<code>BLUE = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.CYAN","title":"<code>CYAN = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.DARK_GRAY","title":"<code>DARK_GRAY = '\\x1b[90m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.GREEN","title":"<code>GREEN = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_BLUE","title":"<code>LIGHT_BLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_CYAN","title":"<code>LIGHT_CYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_GRAY","title":"<code>LIGHT_GRAY = '\\x1b[37m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_GREEN","title":"<code>LIGHT_GREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_PURPLE","title":"<code>LIGHT_PURPLE = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_RED","title":"<code>LIGHT_RED = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.LIGHT_YELLOW","title":"<code>LIGHT_YELLOW = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.PURPLE","title":"<code>PURPLE = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.RED","title":"<code>RED = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.WHITE","title":"<code>WHITE = '\\x1b[97m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Color.YELLOW","title":"<code>YELLOW = '\\x1b[33m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Format.color","title":"<code>color = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Format.style","title":"<code>style = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Format.__init__","title":"<code>__init__(color=None, style=None)</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.VALID_KEYS","title":"<code>VALID_KEYS = {'color', 'style'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.matched_cells","title":"<code>matched_cells = self._parse_format(matched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.matched_rows","title":"<code>matched_rows = self._parse_format(matched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.mismatched_cells","title":"<code>mismatched_cells = self._parse_format(mismatched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.mismatched_rows","title":"<code>mismatched_rows = self._parse_format(mismatched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/formatting/#chispa.formatting.Style.BLINK","title":"<code>BLINK = '\\x1b[5m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Style.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Style.HIDE","title":"<code>HIDE = '\\x1b[8m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Style.INVERT","title":"<code>INVERT = '\\x1b[7m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.Style.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/#chispa.formatting.blue","title":"<code>blue(string)</code>","text":"Source code in <code>chispa/formatting/format_string.py</code> <pre><code>def blue(string: str) -&gt; str:\n    return Color.LIGHT_BLUE + string + Color.LIGHT_RED\n</code></pre>"},{"location":"reference/chispa/formatting/format_string/","title":"Format string","text":""},{"location":"reference/chispa/formatting/format_string/#chispa.formatting.format_string.blue","title":"<code>blue(string)</code>","text":"Source code in <code>chispa/formatting/format_string.py</code> <pre><code>def blue(string: str) -&gt; str:\n    return Color.LIGHT_BLUE + string + Color.LIGHT_RED\n</code></pre>"},{"location":"reference/chispa/formatting/format_string/#chispa.formatting.format_string.format_string","title":"<code>format_string(input_string, format)</code>","text":"Source code in <code>chispa/formatting/format_string.py</code> <pre><code>def format_string(input_string: str, format: Format) -&gt; str:\n    if not format.color and not format.style:\n        return input_string\n\n    formatted_string = input_string\n    codes = []\n\n    if format.style:\n        for style in format.style:\n            codes.append(style.value)\n\n    if format.color:\n        codes.append(format.color.value)\n\n    formatted_string = \"\".join(codes) + formatted_string + RESET\n    return formatted_string\n</code></pre>"},{"location":"reference/chispa/formatting/formats/","title":"Formats","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.RESET","title":"<code>RESET = '\\x1b[0m'</code>  <code>module-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for terminal colors. Each color is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"\n    Enum for terminal colors.\n    Each color is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BLACK = \"\\033[30m\"\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    YELLOW = \"\\033[33m\"\n    BLUE = \"\\033[34m\"\n    PURPLE = \"\\033[35m\"\n    CYAN = \"\\033[36m\"\n    LIGHT_GRAY = \"\\033[37m\"\n    DARK_GRAY = \"\\033[90m\"\n    LIGHT_RED = \"\\033[91m\"\n    LIGHT_GREEN = \"\\033[92m\"\n    LIGHT_YELLOW = \"\\033[93m\"\n    LIGHT_BLUE = \"\\033[94m\"\n    LIGHT_PURPLE = \"\\033[95m\"\n    LIGHT_CYAN = \"\\033[96m\"\n    WHITE = \"\\033[97m\"\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.BLACK","title":"<code>BLACK = '\\x1b[30m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.BLUE","title":"<code>BLUE = '\\x1b[34m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.CYAN","title":"<code>CYAN = '\\x1b[36m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.DARK_GRAY","title":"<code>DARK_GRAY = '\\x1b[90m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.GREEN","title":"<code>GREEN = '\\x1b[32m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_BLUE","title":"<code>LIGHT_BLUE = '\\x1b[94m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_CYAN","title":"<code>LIGHT_CYAN = '\\x1b[96m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_GRAY","title":"<code>LIGHT_GRAY = '\\x1b[37m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_GREEN","title":"<code>LIGHT_GREEN = '\\x1b[92m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_PURPLE","title":"<code>LIGHT_PURPLE = '\\x1b[95m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_RED","title":"<code>LIGHT_RED = '\\x1b[91m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.LIGHT_YELLOW","title":"<code>LIGHT_YELLOW = '\\x1b[93m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.PURPLE","title":"<code>PURPLE = '\\x1b[35m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.RED","title":"<code>RED = '\\x1b[31m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.WHITE","title":"<code>WHITE = '\\x1b[97m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Color.YELLOW","title":"<code>YELLOW = '\\x1b[33m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format","title":"<code>Format</code>  <code>dataclass</code>","text":"<p>Data class to represent text formatting with color and style.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>Color | None</code> <p>The color for the text.</p> <code>style</code> <code>list[Style] | None</code> <p>A list of styles for the text.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>@dataclass\nclass Format:\n    \"\"\"\n    Data class to represent text formatting with color and style.\n\n    Attributes:\n        color (Color | None): The color for the text.\n        style (list[Style] | None): A list of styles for the text.\n    \"\"\"\n\n    color: Color | None = None\n    style: list[Style] | None = None\n\n    @classmethod\n    def from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a dictionary.\n\n        Args:\n            format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n        \"\"\"\n        if not isinstance(format_dict, dict):\n            raise ValueError(\"Input must be a dictionary\")\n\n        valid_keys = {\"color\", \"style\"}\n        invalid_keys = set(format_dict) - valid_keys\n        if invalid_keys:\n            raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n        if isinstance(format_dict.get(\"color\"), list):\n            raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n        color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n        style = format_dict.get(\"style\")\n        if isinstance(style, str):\n            styles = [cls._get_style_enum(style)]\n        elif isinstance(style, list):\n            styles = [cls._get_style_enum(s) for s in style]\n        else:\n            styles = None\n\n        return cls(color=color, style=styles)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_list(cls, values: list[str]) -&gt; Format:\n        \"\"\"\n        Create a Format instance from a list of strings.\n\n        Args:\n            values (list[str]): A list of strings representing colors and styles.\n        \"\"\"\n        if not all(isinstance(value, str) for value in values):\n            raise ValueError(\"All elements in the list must be strings\")\n\n        color = None\n        styles = []\n        valid_colors = [c.name.lower() for c in Color]\n        valid_styles = [s.name.lower() for s in Style]\n\n        for value in values:\n            if value in valid_colors:\n                color = Color[value.upper()]\n            elif value in valid_styles:\n                styles.append(Style[value.upper()])\n            else:\n                raise ValueError(\n                    f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n                )\n\n        return cls(color=color, style=styles if styles else None)\n\n    @staticmethod\n    def _get_color_enum(color: Color | str | None) -&gt; Color | None:\n        if isinstance(color, Color):\n            return color\n        elif isinstance(color, str):\n            try:\n                return Color[color.upper()]\n            except KeyError:\n                valid_colors = [c.name.lower() for c in Color]\n                raise ValueError(f\"Invalid color name: {color}. Valid color names are {valid_colors}\")\n        return None\n\n    @staticmethod\n    def _get_style_enum(style: Style | str | None) -&gt; Style | None:\n        if isinstance(style, Style):\n            return style\n        elif isinstance(style, str):\n            try:\n                return Style[style.upper()]\n            except KeyError:\n                valid_styles = [f.name.lower() for f in Style]\n                raise ValueError(f\"Invalid style name: {style}. Valid style names are {valid_styles}\")\n        return None\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.color","title":"<code>color = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.style","title":"<code>style = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.__init__","title":"<code>__init__(color=None, style=None)</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.from_dict","title":"<code>from_dict(format_dict)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>format_dict</code> <code>dict</code> <p>A dictionary with keys 'color' and/or 'style'.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_dict(cls, format_dict: dict[str, str | list[str]]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a dictionary.\n\n    Args:\n        format_dict (dict): A dictionary with keys 'color' and/or 'style'.\n    \"\"\"\n    if not isinstance(format_dict, dict):\n        raise ValueError(\"Input must be a dictionary\")\n\n    valid_keys = {\"color\", \"style\"}\n    invalid_keys = set(format_dict) - valid_keys\n    if invalid_keys:\n        raise ValueError(f\"Invalid keys in format dictionary: {invalid_keys}. Valid keys are {valid_keys}\")\n\n    if isinstance(format_dict.get(\"color\"), list):\n        raise TypeError(\"The value for key 'color' should be a string, not a list!\")\n    color = cls._get_color_enum(format_dict.get(\"color\"))  # type: ignore[arg-type]\n\n    style = format_dict.get(\"style\")\n    if isinstance(style, str):\n        styles = [cls._get_style_enum(style)]\n    elif isinstance(style, list):\n        styles = [cls._get_style_enum(s) for s in style]\n    else:\n        styles = None\n\n    return cls(color=color, style=styles)  # type: ignore[arg-type]\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Format.from_list","title":"<code>from_list(values)</code>  <code>classmethod</code>","text":"<p>Create a Format instance from a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[str]</code> <p>A list of strings representing colors and styles.</p> required Source code in <code>chispa/formatting/formats.py</code> <pre><code>@classmethod\ndef from_list(cls, values: list[str]) -&gt; Format:\n    \"\"\"\n    Create a Format instance from a list of strings.\n\n    Args:\n        values (list[str]): A list of strings representing colors and styles.\n    \"\"\"\n    if not all(isinstance(value, str) for value in values):\n        raise ValueError(\"All elements in the list must be strings\")\n\n    color = None\n    styles = []\n    valid_colors = [c.name.lower() for c in Color]\n    valid_styles = [s.name.lower() for s in Style]\n\n    for value in values:\n        if value in valid_colors:\n            color = Color[value.upper()]\n        elif value in valid_styles:\n            styles.append(Style[value.upper()])\n        else:\n            raise ValueError(\n                f\"Invalid value: {value}. Valid values are colors: {valid_colors} and styles: {valid_styles}\"\n            )\n\n    return cls(color=color, style=styles if styles else None)\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style","title":"<code>Style</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for text styles. Each style is represented by its corresponding ANSI escape code.</p> Source code in <code>chispa/formatting/formats.py</code> <pre><code>class Style(str, Enum):\n    \"\"\"\n    Enum for text styles.\n    Each style is represented by its corresponding ANSI escape code.\n    \"\"\"\n\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    BLINK = \"\\033[5m\"\n    INVERT = \"\\033[7m\"\n    HIDE = \"\\033[8m\"\n</code></pre>"},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style.BLINK","title":"<code>BLINK = '\\x1b[5m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style.BOLD","title":"<code>BOLD = '\\x1b[1m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style.HIDE","title":"<code>HIDE = '\\x1b[8m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style.INVERT","title":"<code>INVERT = '\\x1b[7m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formats/#chispa.formatting.formats.Style.UNDERLINE","title":"<code>UNDERLINE = '\\x1b[4m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/","title":"Formatting config","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig","title":"<code>FormattingConfig</code>","text":"<p>Class to manage and parse formatting configurations.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>class FormattingConfig:\n    \"\"\"\n    Class to manage and parse formatting configurations.\n    \"\"\"\n\n    VALID_KEYS: ClassVar = {\"color\", \"style\"}\n\n    def __init__(\n        self,\n        mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n        matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n        mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n        matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    ):\n        \"\"\"\n        Initializes the FormattingConfig with given or default formatting.\n\n        Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n        - 'color': A string representing a color name, which should be one of the valid colors:\n            ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n            'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n            'light_purple', 'light_cyan', 'white'].\n        - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n            ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n        Args:\n            mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n            matched_rows (Format | dict): Format or dictionary for matched rows.\n            mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n            matched_cells (Format | dict): Format or dictionary for matched cells.\n\n        Raises:\n            ValueError: If the dictionary contains invalid keys or values.\n        \"\"\"\n        self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n        self.matched_rows: Format = self._parse_format(matched_rows)\n        self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n        self.matched_cells: Format = self._parse_format(matched_cells)\n\n    def _parse_format(self, format: Format | dict[str, str | list[str]]) -&gt; Format:\n        if isinstance(format, Format):\n            return format\n        elif isinstance(format, dict):\n            return Format.from_dict(format)\n        raise ValueError(\"Invalid format type. Must be Format or dict.\")\n\n    @classmethod\n    def _from_arbitrary_dataclass(cls, instance: Any) -&gt; FormattingConfig:\n        \"\"\"\n        Converts an instance of an arbitrary class with specified fields to a FormattingConfig instance.\n        This method is purely for backwards compatibility and should be removed in a future release,\n        together with the `DefaultFormats` class.\n        \"\"\"\n\n        if not isinstance(instance, DefaultFormats):\n            warnings.warn(\n                \"Using an arbitrary dataclass is deprecated. Use `chispa.formatting.FormattingConfig` instead.\",\n                DeprecationWarning,\n            )\n\n        mismatched_rows = Format.from_list(getattr(instance, \"mismatched_rows\"))\n        matched_rows = Format.from_list(getattr(instance, \"matched_rows\"))\n        mismatched_cells = Format.from_list(getattr(instance, \"mismatched_cells\"))\n        matched_cells = Format.from_list(getattr(instance, \"matched_cells\"))\n\n        return cls(\n            mismatched_rows=mismatched_rows,\n            matched_rows=matched_rows,\n            mismatched_cells=mismatched_cells,\n            matched_cells=matched_cells,\n        )\n</code></pre>"},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.VALID_KEYS","title":"<code>VALID_KEYS = {'color', 'style'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.matched_cells","title":"<code>matched_cells = self._parse_format(matched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.matched_rows","title":"<code>matched_rows = self._parse_format(matched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.mismatched_cells","title":"<code>mismatched_cells = self._parse_format(mismatched_cells)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.mismatched_rows","title":"<code>mismatched_rows = self._parse_format(mismatched_rows)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/chispa/formatting/formatting_config/#chispa.formatting.formatting_config.FormattingConfig.__init__","title":"<code>__init__(mismatched_rows=Format(Color.RED), matched_rows=Format(Color.BLUE), mismatched_cells=Format(Color.RED, [Style.UNDERLINE]), matched_cells=Format(Color.BLUE))</code>","text":"<p>Initializes the FormattingConfig with given or default formatting.</p> <p>Each of the arguments can be provided as a <code>Format</code> object or a dictionary with the following keys: - 'color': A string representing a color name, which should be one of the valid colors:     ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',     'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',     'light_purple', 'light_cyan', 'white']. - 'style': A string or list of strings representing styles, which should be one of the valid styles:     ['bold', 'underline', 'blink', 'invert', 'hide'].</p> <p>Parameters:</p> Name Type Description Default <code>mismatched_rows</code> <code>Format | dict</code> <p>Format or dictionary for mismatched rows.</p> <code>Format(RED)</code> <code>matched_rows</code> <code>Format | dict</code> <p>Format or dictionary for matched rows.</p> <code>Format(BLUE)</code> <code>mismatched_cells</code> <code>Format | dict</code> <p>Format or dictionary for mismatched cells.</p> <code>Format(RED, [UNDERLINE])</code> <code>matched_cells</code> <code>Format | dict</code> <p>Format or dictionary for matched cells.</p> <code>Format(BLUE)</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary contains invalid keys or values.</p> Source code in <code>chispa/formatting/formatting_config.py</code> <pre><code>def __init__(\n    self,\n    mismatched_rows: Format | dict[str, str | list[str]] = Format(Color.RED),\n    matched_rows: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n    mismatched_cells: Format | dict[str, str | list[str]] = Format(Color.RED, [Style.UNDERLINE]),\n    matched_cells: Format | dict[str, str | list[str]] = Format(Color.BLUE),\n):\n    \"\"\"\n    Initializes the FormattingConfig with given or default formatting.\n\n    Each of the arguments can be provided as a `Format` object or a dictionary with the following keys:\n    - 'color': A string representing a color name, which should be one of the valid colors:\n        ['black', 'red', 'green', 'yellow', 'blue', 'purple', 'cyan', 'light_gray',\n        'dark_gray', 'light_red', 'light_green', 'light_yellow', 'light_blue',\n        'light_purple', 'light_cyan', 'white'].\n    - 'style': A string or list of strings representing styles, which should be one of the valid styles:\n        ['bold', 'underline', 'blink', 'invert', 'hide'].\n\n    Args:\n        mismatched_rows (Format | dict): Format or dictionary for mismatched rows.\n        matched_rows (Format | dict): Format or dictionary for matched rows.\n        mismatched_cells (Format | dict): Format or dictionary for mismatched cells.\n        matched_cells (Format | dict): Format or dictionary for matched cells.\n\n    Raises:\n        ValueError: If the dictionary contains invalid keys or values.\n    \"\"\"\n    self.mismatched_rows: Format = self._parse_format(mismatched_rows)\n    self.matched_rows: Format = self._parse_format(matched_rows)\n    self.mismatched_cells: Format = self._parse_format(mismatched_cells)\n    self.matched_cells: Format = self._parse_format(matched_cells)\n</code></pre>"}]}